#! /usr/bin/env mulle-bash
# shellcheck shell=bash
#
# shellcheck shell=bash
# shellcheck disable=SC2236 # ! -z
# shellcheck disable=SC1090 # include
# shellcheck disable=SC1091 # include
# shellcheck disable=SC2120 # log_entry misfire
# shellcheck disable=SC2166 # [ p -o q ] don't care
#
#   Copyright (c) 2015 Nat! - Mulle kybernetiK
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are met:
#
#   Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
#   Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
#   Neither the name of Mulle kybernetiK nor the names of its contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
[ "${TRACE}" = 'YES' -o "${MULLE_ENV_TRACE}" = 'YES' ] && set -x && : "$0" "$@"

MULLE_EXECUTABLE_VERSION="5.0.0"


#
# Determine location of own libexec directory. Which is `src` in development
# and ../libexec when deployed. MULLE_EXECUTABLE needs to be defined for this.
#

if ! [ ${MULLE_ENV_LIBEXEC_DIR+x} ]
then
   r_get_libexec_dir "${MULLE_EXECUTABLE}" "mulle-env" "mulle-env-init.sh"
   MULLE_ENV_LIBEXEC_DIR="${RVAL}"
fi

#
# The default for first time mulle-env
#
MULLE_ENV_DEFAULT_STYLE="developer/relax"
ENVFILENAME="environment.sh"
AUXENVFILENAME=

env::emit_options()
{
   cat <<EOF
   -C <cmd>      : as -c but no shell expansion, command/args are LF separated
   -c <cmd>      : shell command to execute instead of interactive subshell
   -d <dir>      : specify directory
   -DKEY=VALUE   : define one-time environment variable
   -ef <file>    : use a different environment file (${ENVFILENAME})
   -aef <file>   : add another environment file to an interactive subshell
   --search-here : search only in PWD, if none present ignore
   --search-none : search only in PWD, if none present fail
   -N            : search for nearest enclosing environment
   -P            : search for parent environment
   -p <path>     : specify an additional plugin search path
   -S            : search for superior environment
   --style <t/e> : enter and change subshell style (${MULLE_ENV_DEFAULT_STYLE})
EOF

   if [ ! -z "${MULLE_TRACE:-}" ]
   then
      options_technical_flags_usage "         : "
   fi
}


#
# relax has this problem, that on linux cmake is installed in /bin
# and everything works fine and then you go to darwin where its in
# /usr/local/bin and things fail
#
env::usage()
{
   [ $# -ne 0 ] && log_error "$1"

    cat <<EOF >&2
Usage:
   ${MULLE_USAGE_NAME} [options] [commands] [path-or-url]

   Create a virtual environment with a custom set of environment variables
   and tools for use in a subshell. Use the -ef option to specify an
   environment file or let mulle-env search for a default environment.sh
   file in your local .mulle/etc/env ot .mulle/share/env folder.

   If the directory at "path-or-url" does not exist and the path looks like
   an URL, then ${MULLE_USAGE_NAME} will attempt to \`git clone\` that URL.

   Use the -c or -C options to run commands in the virtual environment
   without entering an interactive subshell.
EOF

   if [ ! -z "${MULLE_TRACE}" ]
   then
      cat <<EOF >&2

   Use --style "none/wild" for no PATH and environment restrictions. Aliases
   and shell settings will still be suppressed.
EOF
   fi

   cat <<EOF >&2

Options:
EOF
   env::emit_options | LC_ALL=C sort >&2

   cat <<EOF >&2

Commands:
   clean         : force relink of tools on next entry
   environment   : manage subshell environment variables
   init          : set up the subshell for the first time
   invoke        : execute a shell command with restricted environment
   style         : manage environment style of directory (PWD)
   subenv        : enter a sub environment
   tool          : manage subshell tools
   uname         : return the ${MULLE_USAGE_NAME} specific uname
   upgrade       : upgrade a subshell to a newer mulle-env version
   version       : return the ${MULLE_USAGE_NAME} version
   --            : enter the subshell
EOF

  exit 1
}


#
# start:     starting directory
# search:    NONE (doesn't climb), NEAREST, PARENT, SUPERIOR, DEFAULT
#
#            NONE:     does not climb, unhappy if none present at start
#            NEAREST:  climb up until happy
#            PARENT:   do NEAREST first, then look for PARENT
#            SUPERIOR: find highes PARENT
#            DEFAULT:  NEAREST with added defer for master/minion configuration
#            AS_IS:    NEAREST with fallback to start
#            HERE:     just this without checks
#
env::r_find_best_environment()
{
   log_entry "env::r_find_best_environment" "$@"

   local start="$1"
   local searchmode="$2"

   local directory
   local best
   local warn
   local searchfile

   r_absolutepath "${start}"
   directory="${RVAL}"  # paranoia

   case "${searchmode}" in
      'HERE')
         RVAL="${start}"
         return
      ;;

      'AS_IS')
         best="${start}"
      ;;
   esac

   warn='NO'

   while :
   do
      searchfile="${directory}/.mulle/share/env/environment.sh"
      if [ -f "${searchfile}" ]
      then
         log_debug "Found \"${searchfile}\""

         case "${searchmode}" in
            'PARENT')
               if [ ! -z "${best}" ]
               then
                  RVAL="${directory}"
                  return
               fi
            ;;

            'SUPERIOR')
               log_debug "Keep looking past \"${directory}\""
            ;;

            'NONE'|'NEAREST'|'AS_IS')
               RVAL="${directory}"
               return
            ;;

            'DEFAULT')
               if [ -f "${directory}/.mulle/share/env/defer" -o \
                    -f "${directory}/.mulle/etc/env/defer" ]
               then
                  log_verbose "\"${directory#"${MULLE_USER_PWD}/"}\" is defering with tweak \"defer\""
               else
                  RVAL="${directory}"
                  return
               fi
            ;;

            *)
               _internal_fail "unknown searchmode \"${searchmode}\""
            ;;
         esac
         best="${directory}"
      else
         log_debug "Did not find \"${searchfile}\""
         case "${searchmode}" in
            NONE)
               RVAL=""
               return 1
            ;;
         esac
      fi

      r_dirname "${directory}"
      directory="${RVAL}"

      # look for .mulle/share/env/*/environment.sh going up to root, if we
      # find one, we latch onto it
      if [ "${directory}" = "/" ]
      then
         RVAL="${best}"
         return
      fi
   done

   if [ "${warn}" = 'YES' ]
   then
      _log_info "Using the superior mulle-env environment at \
${C_RESET_BOLD}${best}${C_INFO}.
Suppress this behaviour with the flag \"-N\" or permanently suppress on a
per environment basis with:
   ${C_RESET_BOLD}mulle-env tweak subproject"

   fi

   log_debug "Accept ${best} as superior"
   RVAL="${best}"
}


env::setup_environment()
{
   log_entry "env::setup_environment" "$@"

   local directory="$1"
   local setroot="$2"

   [ -z "${MULLE_UNAME}" ]   && _internal_fail "MULLE_UNAME not set"
   [ -z "${MULLE_HOSTNAME}" ] && _internal_fail "MULLE_HOSTNAME not set"

   local physicaldir

   r_physicalpath "${directory:-${PWD}}" || _internal_fail "physicalpath failed"
   physicaldir="${RVAL}"

   [ ! -d "${physicaldir}" ]  && fail "\"${directory}\" is not a directory"
   [ "${physicaldir}" = "/" ] && fail "Running in / which is not supported"

   if [ "${setroot}" = 'YES' ]
   then
      MULLE_VIRTUAL_ROOT="${physicaldir}"
      log_fluff "mulle-env sets MULLE_VIRTUAL_ROOT to \"${MULLE_VIRTUAL_ROOT}\""
   fi

   #
   # MULLE_ENV_VAR_DIR is for mulle-sde tools (bash scripts)
   # MULLE_ENV_HOST_VAR_DIR for all the rest
   # these can be overidden by command line parameters, for special needs
   # people with read-only read/write setups
   #
   case "${MULLE_UNAME}" in
      'mingw'|'msys')
         #
         # (actual windows works though)
         #
         # on windows the project directory is likely on a windows filesystem
         # so the symlinks don't work out (e.g. cmake.exe) ???? Still true ??
         # Symlinks still have other problems: https://github.com/microsoft/WSL/issues/3999
         # We use a quiet place in HOME. A problem is that this tends to fill
         # up.
         #
         # Use physicaldir for shasum calc. TODO
         #
         if [ -z "${MULLE_ENV_HOST_VAR_DIR}" ]
         then
            r_fnv1a_32 "${physicaldir}"
            printf -v hash "%08x" "${RVAL}"
            MULLE_ENV_HOST_VAR_DIR="${HOME}/.mulle/${directory##*/}-${hash}.var/${MULLE_HOSTNAME}/env"
         fi
         MULLE_ENV_VAR_DIR="${MULLE_ENV_VAR_DIR:-"${HOME}/.mulle/${directory##*/}.var/.env"}"
      ;;

      *)
         MULLE_ENV_HOST_VAR_DIR="${MULLE_ENV_HOST_VAR_DIR:-"${physicaldir}/.mulle/var/${MULLE_HOSTNAME}/env"}"
         MULLE_ENV_VAR_DIR="${MULLE_ENV_VAR_DIR:-"${physicaldir}/.mulle/var/.env"}"
      ;;
   esac

   MULLE_ENV_SHARE_DIR="${physicaldir}/.mulle/share/env"
   MULLE_ENV_ETC_DIR="${physicaldir}/.mulle/etc/env"

#   if [ "${MULLE_FLAG_LOG_SETTINGS}" = 'YES' ]
#   then
#      log_setting "MULLE_VIRTUAL_ROOT:     \"${MULLE_VIRTUAL_ROOT}\""
#      log_setting "MULLE_ENV_ETC_DIR:      \"${MULLE_ENV_ETC_DIR}\""
#      log_setting "MULLE_ENV_SHARE_DIR:    \"${MULLE_ENV_SHARE_DIR}\""
#      log_setting "MULLE_ENV_VAR_DIR:      \"${MULLE_ENV_VAR_DIR}\""
#      log_setting "MULLE_ENV_HOST_VAR_DIR: \"${MULLE_ENV_HOST_VAR_DIR}\""
#   fi
}


env::default_setup_environment()
{
   log_entry "env::default_setup_environment" "$@"

   local indirectory="$1"
   local searchmode="$2"
   local setroot="${3:-YES}"
   local failonerror="${4:-YES}"

   local directory

   directory="${indirectory:-${PWD}}"
   if [ ! -d "${directory:-${PWD}}" ]
   then
      fail "Can't access \"${indirectory:-current directory}\""
   fi

   env::r_find_best_environment "${directory}" "${searchmode}"
   if [ -z "${RVAL}" ]
   then
      if [ "${failonerror}" = 'YES' -a "${FLAG_OUTSIDE_ENV}" != 'YES' ]
      then
         fail "No suitable environment found for ${directory} (init it first)"
      fi
      return 1
   fi

   [ ! -d "${RVAL}" ] && fail "${RVAL} does not exist (init it first)"

   directory="${RVAL}"

   log_fluff "Environment directory determined to be \"${directory}\""
   env::setup_environment "${directory}" "${setroot}"
}


env::protect_dir_if_exists()
{
   log_entry "env::protect_dir_if_exists" "$@"

   local directory="$1"

   if [ "${OPTION_PROTECT}" = 'YES' ]
   then
      if [ -d "${directory}" ]
      then
         if ! exekutor chmod -R -f a-w "${directory}"
         then
            case "${MULLE_UNAME}" in
               android)
                  # sees that it can't protect symlinks, complains
               ;;

               *)
                  _internal_fail "Could not protect \"${directory}\""
               ;;
            esac
         fi
      fi
   fi
}


env::unprotect_dir_if_exists()
{
   log_entry "env::unprotect_dir_if_exists" "$@"

   local directory="$1"

   if [ "${OPTION_PROTECT}" = 'YES' ]
   then
      if [ -d "${directory}" ]
      then
         if ! exekutor chmod -R -f ug+wX "${directory}"
         then
            case "${MULLE_UNAME}" in
               android)
                  # sees that it can't protect symlinks, complains
               ;;

               *)
                  _internal_fail "Could not unprotect \"${directory}\""
               ;;
            esac
         fi
      fi
   fi
}


#
# tool support
#
env::__get_tool_filepath()
{
   local os="$1"

   if [ -z "${os}" -o "${os}" = "DEFAULT" ]
   then
      _filepath="${MULLE_ENV_SHARE_DIR}/tool-plugin\
:${MULLE_ENV_SHARE_DIR}/tool-extension\
:${MULLE_ENV_ETC_DIR}/tool"
   else
      _filepath="${MULLE_ENV_SHARE_DIR}/tool-plugin\
:${MULLE_ENV_SHARE_DIR}/tool-plugin.${os}\
:${MULLE_ENV_SHARE_DIR}/tool-extension\
:${MULLE_ENV_SHARE_DIR}/tool-extension.${os}\
:${MULLE_ENV_ETC_DIR}/tool\
:${MULLE_ENV_ETC_DIR}/tool.${os}"
   fi
}


env::r_get_existing_tool_filepath()
{
   log_entry "env::r_get_existing_tool_filepath" "$@"

   local _filepath

   env::__get_tool_filepath "$@"

   local file

   RVAL=""

   .foreachpath file in ${_filepath}
   .do
      if [ ! -f "${file}" ]
      then
         log_debug "\"${file}\" does not exist"
         .continue
      fi

      r_colon_concat "${RVAL}" "${file}"
   .done
}


# 0 dont compile
# 1 need compile
# 4 nothing defined
env::get_tool_status()
{
   log_entry "env::get_tool_status" "$@"

   local filepath

   env::r_get_existing_tool_filepath "${MULLE_UNAME}"
   filepath="${RVAL}"

   log_debug "Checking if compile is needed with: ${filepath}"

   local anymatch

   anymatch='NO'

   .foreachpath file in ${filepath}
   .do
      # make same date force recompile, because we can't be sure then
      if [ "${MULLE_ENV_HOST_VAR_DIR}/tool" -nt "${file}" ]
      then
         log_debug "\"${file}\" is not newer than \"${MULLE_ENV_HOST_VAR_DIR}/tool\""
      else
         log_fluff "Compile is needed because \"${file}\" has edits"
         return 1
      fi
      anymatch='YES'
   .done

   if [ "${anymatch}" = 'YES' -o -f "${MULLE_ENV_HOST_VAR_DIR}/tool" ]
   then
      return 0
   fi
   return 4
}


#
# Check that any symlink in .mulle/var/etc/bin is still valid
# returns 0 if OK
# The contents of MULLE_ENV_VAR_DIR/bin are actually installed by the mulle.sh
# plugin so this code should also move to the plugin.
#
env::get_symlink_status()
{
   log_entry "env::get_symlink_status" "$@"

   local rval

   rval=0

   local filename
   local resolved

   shell_enable_nullglob
   for filename in "${MULLE_ENV_VAR_DIR}/bin/"*
   do
      shell_disable_nullglob

      # quick check, assume either all symlinks or none
      if [ -L "${filename}" ]
      then
         resolved="`readlink "${filename}"`"
         if [ ! -e "${resolved}" ]
         then
            log_fluff "Symlink is \"${filename}\" to \"${resolved}\" is broken"
            rval=1
         fi
      fi
      break # first file decides
   done
   shell_disable_nullglob

   return $rval
}


#
# dealing with styles and flavors and their changes
#
env::r_get_saved_version()
{
   log_entry "env::r_get_saved_version" "$@"

   local sharedir="$1"
   local fallbackroot="$2"

   RVAL="`rexekutor grep -E -v '^#' "${sharedir}/version" 2> /dev/null`"
   if [ "${RVAL}" = "" ]
   then
      # old location
      RVAL="`rexekutor grep -E -v '^#' "${fallbackroot}/.mulle-env/share/version" 2> /dev/null`"
   fi

   case "${RVAL}" in
      "")
         return 1
      ;;

      *[^0-9.]*)
         fail "Old version ${RVAL} looks corrupted"
      ;;
   esac

   return 0
}


env::check_version()
{
   log_entry "env::check_version" "$@"

   if [ "${MULLE_FLAG_MAGNUM_FORCE}" = 'YES' ]
   then
      return
   fi

   local version

   env::r_get_saved_version "$@"
   version="${RVAL}"

   case "${version}" in
      "")
         # allow mulle-sde to squelch this with -s
         log_warning "\"${PWD}\" is not a mulle-env environment (no version information found)"
         exit 1
      ;;

      [012]\.*)
         # incompatible change of -c execution, otherwise try to support
         # and make this a warning
         fail "This environment with version ${version} is too old for
mulle-env ${MULLE_EXECUTABLE_VERSION}.
${C_INFO}You can upgrade to ${MULLE_EXECUTABLE_VERSION} with:
${C_RESET_BOLD}   cd \"${MULLE_VIRTUAL_ROOT}\"
${C_RESET_BOLD}   ${MULLE_USAGE_NAME} upgrade"
      ;;

      [345]\.*)
      ;;

      *)
         fail "This environment requires a newer mulle-env version >= ${version}.
   ${C_RESET_BOLD}You are running mulle-env version ${MULLE_EXECUTABLE_VERSION}."
      ;;
   esac
}


env::setup_if_needed()
{
   log_entry "env::setup_if_needed" "$@"

   local directory="$1"
   local vardir="$2"
   local sharedir="$3"
   local style="$4"
   local flavor="$5"
   local oldstyle="$6"
   local oldflavor="$7"

   local bindir
   local libexecdir

   bindir="${vardir}/bin"
   libexecdir="${vardir}/libexec"

   local needs_flavor_update
   local needs_bin_update

   needs_flavor_update='NO'
   needs_bin_update='DEFAULT'

   #
   # need to do this to convert from developer back to minimal or none
   #
   if [ "${style}" != "${oldstyle}" ]
   then
      rmdir_safer "${bindir}"
      rmdir_safer "${libexecdir}"
      needs_bin_update='YES'
   fi

   if [ "${flavor}" != "${oldflavor}" ]
   then
      _log_info "You affected a tool style change from \
\"${oldflavor}\" to \"${flavor}\". You may want to
check your tool list.
   ${C_RESET_BOLD} mulle-env tool list"
   fi

   if [ "${needs_bin_update}" = 'DEFAULT' ]
   then
      if env::get_tool_status && env::get_symlink_status
      then
         needs_bin_update='NO'
      else
         needs_bin_update='YES'
      fi
   fi

   if [ "${needs_bin_update}" = 'YES' ]
   then
      [ -z "${MULLE_ENV_TOOL_SH}" ] && \
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-tool.sh"

      local callback
      local rval

      env::unprotect_dir_if_exists "${bindir}"
      env::unprotect_dir_if_exists "${libexecdir}"
      (
	      (
	         callback="env::plugin::${flavor}::setup_tools"
	         if shell_is_function "${callback}"
	         then
	            ${callback} "${bindir}" "${libexecdir}" || exit 1
	         fi
	      ) || exit 1

	      if ! (
	         env::tool::link --compile \
	                         --bindir "${bindir}"
	      )
	      then
	         # force needs_bin_update on next update
	         remove_file_if_present "${MULLE_ENV_HOST_VAR_DIR}/tool"
	         exit 1
	      fi
	   )
	   rval=$?

      env::protect_dir_if_exists "${bindir}"
      env::protect_dir_if_exists "${libexecdir}"

      [ "$rval" -ne 0 ] && exit $rval
   fi
}


#
# also check version
#
env::fail_get_saved_style_flavor()
{
   log_entry "env::fail_get_saved_style_flavor" "$@"

   local directory="$1"
   local fallback="$2"

   r_simplified_absolutepath "${directory}"
   directory="${RVAL}"

   local userdir

   r_dirname "${directory}"  # ../env
   r_dirname "${RVAL}"       # ../share
   r_dirname "${RVAL}"       # ../.mulle
   userdir="${RVAL}"

   if [ -z "${fallback}" ]
   then
      fail "No properly setup environment found in project \
directory \"${userdir#"${MULLE_USER_PWD}/"}\" as \"${directory#"${MULLE_USER_PWD}/"}\" contains no \
style information."
   else
      fail "No properly setup environment found in project \
directory \"${userdir#"${MULLE_USER_PWD}/"}\" as \"${directory#"${MULLE_USER_PWD}/"}\" or \"${fallback#"${MULLE_USER_PWD}/"}\" contain no \
style information."
   fi
}

# local _style
# local _flavor
env::__get_saved_style_flavor()
{
   log_entry "env::__get_saved_style_flavor" "$@"

   local directory="$1"
   local fallback="$2"

   local filename

   # make foo:bar foo/bar for backwards compatibility
   filename="${directory}/style.${LOGNAME:-all}"
   _style="`rexekutor sed -e '/^#/d' -e 's|:|/|g' "${filename}" 2> /dev/null `"
   if [ -z "${_style}" ]
   then
      filename="${fallback}/style"
      _style="`rexekutor sed -e '/^#/d' -e 's|:|/|g' "${filename}" 2> /dev/null `"
      if [ -z "${_style}" ]
      then
         log_debug "No previous style found ${filename}"
         return 1
      fi
   fi
   log_fluff "Previous style \"${_style}\" found in \"${filename}\""

   _flavor="${_style%%/*}"
   return 0
}


# local _style
# local _flavor
env::__get_style_flavor()
{
   log_entry "env::__get_style_flavor" "$@"

   _style="$1"
   _flavor="${_style%%/*}"
}


env::load_flavor_plugin()
{
   log_entry "env::load_flavor_plugin" "$@"

   local flavor="$1"

   log_debug "load env::plugin ->"
   include "env::plugin"
   log_debug "load env::plugin <-"

   local searchpath

   env::plugin::r_searchpath
   searchpath="${RVAL}"

   if ! env::plugin::do_load "${flavor}" "${searchpath}"
   then
      if [ "${MULLE_FLAG_MAGNUM_FORCE}" != 'YES' ]
      then
         fail "No plugin \"${flavor}\" found in \"${searchpath}\".
${C_INFO}Fixes:
   * install the missing mulle-env plugin or modify MULLE_ENV_PLUGIN_PATH
   * use ${MULLE_USAGE_NAME} -f to skip this check.
   * change to an available style with ${MULLE_USAGE_NAME} --style"
      fi
      return 1
   fi

   log_fluff "Env plugin \"${flavor}\" loaded"
	log_verbose "Using plugin ${C_MAGENTA}${C_BOLD}${flavor}"
}


env::write_cachedir_tag()
{
   log_entry "env::write_cachedir_tag" "$@"

   local vardir="$1"

   [ "${MULLE_CACHEDIR_TAG}" != "YES" ] && return

   r_basename "${vardir}"
   if [ "${RVAL}" = ".env" ]
   then
      r_dirname "${vardir}"
      vardir="${RVAL}"
   fi

   # assume one stat is faster than open/write/close
   [ -f "${vardir}/CACHEDIR.TAG" ] && return

   redirect_exekutor "${vardir}/CACHEDIR.TAG" printf "%s\n" "\
Signature: 8a477f597d28d172789f06886806bc55

This file is a cache directory tag created by mulle-env.
If you use \`tar --exclude-caches-all\`, this directory will be excluded from
your archive.

You can suppress the generation of this file with:
   mulle-sde env --global set MULLE_CACHEDIR_TAG NO
"
}


env::apply_style_to_directory()
{
   log_entry "env::apply_style_to_directory" "$@"

   local directory="$1"
   local sharedir="$2"
   local style="$3"
   local flavor="$4"

   local callback

   callback="env::plugin::${flavor}::enter_subshell"
   if shell_is_function "${callback}"
   then
      ${callback} "${directory}" "${style}"
   fi

   # memorize new style
   # since this always changes on user reques its in etc
   mkdir_if_missing "${MULLE_ENV_HOST_VAR_DIR}"
   env::write_cachedir_tag "${MULLE_ENV_VAR_DIR}"
   redirect_exekutor "${MULLE_ENV_HOST_VAR_DIR}/style.${LOGNAME:-all}" printf "%s\n" "${style}"
}


env::r_apply_flavor_to_runpath()
{
   log_entry "env::r_apply_flavor_to_runpath" "$@"

   local directory="$1"
   local flavor="$2"
   local runpath="$3"

   local callback

   RVAL="${runpath}"
   callback="env::plugin::${flavor}::r_add_runpath"
   if shell_is_function "${callback}"
   then
      ${callback} "${directory}" "${RVAL}"
   fi
}


env::r_censored_path()
{
   log_entry "env::r_censored_path" "$@"

   local full_path="$1"

   local i
   local j

   RVAL=""

   [ -z "${RESTRICTED_PATH}" ] && _internal_fail "RESTRICTED_PATH must not be empty"

   .foreachpath i in ${full_path}
   .do
      .foreachpath j in ${RESTRICTED_PATH}
      .do
         if [ "$i" = "$j" ]
         then
            r_colon_concat "${RVAL}" "${i}"
         fi
      .done
   .done

   log_debug "censored path : $RVAL"
}


#
# run shell or command in an inferior mulle-env environment
# This is "wild" style. We don't manipulate the PATH and we
# don't clean the environment. But we augment it with the
# variables set in the inferior ENVFILENAME
#
env::run_subenv()
{
   log_entry "env::run_subenv" "$@"

   local directory="$1"

   r_simplified_absolutepath "${directory:-${PWD}}"
   directory="${RVAL}"

   if [ ! -d "${directory}/.mulle/share/env" ]
   then
      [ -d "${directory}" ] || fail "\"${directory}\" not found"
      fail "No mulle-env found in \"${directory}\""
   fi

   # might need to be smarter here
   case "${directory}" in
      "../"*|*"/.."|*"/../"*|"./"*|*"/."|*"/./"*|"~/"*|*"/~"|*"/~/"*)
         fail "${directory} must not have relative components"
      ;;
   esac

   env::setup_environment "${directory}" "YES"

   local mode

   if [ ! -z "${OPTION_SHELL_COMMAND}" ]
   then
      _log_verbose "Run subenv shell command \
\"${OPTION_SHELL_COMMAND}\" ($MULLE_VIRTUAL_ROOT})"
      mode="SUBENV:SCRIPT"
   else
      _log_info "Starting subenv shell in \
${C_RESET_BOLD}${MULLE_VIRTUAL_ROOT#${PWD}/}${C_INFO}."
      mode="SUBENV:INTERACTIVE"
   fi

   if [ "${PWD}" != "${directory}" ]
   then
      exekutor cd "${directory}" || exit 1
   fi

#   local script
#
#   case "${MULLE_UNAME}" in
#      android)
#         script="${MULLE_ENV_LIBEXEC_DIR}/mulle-env-shell.sh"
#      ;;

#      *)
         script="${MULLE_ENV_LIBEXEC_DIR}/mulle-env-shell"
#      ;;
#   esac

   eval_exekutor env \
      "${CUSTOM_ENVIRONMENT}" \
      "'${script}'" \
        "'${MULLE_UNAME}'" \
        "'${MULLE_HOSTNAME}'" \
        "'${MULLE_USERNAME}'" \
        "'${MULLE_VIRTUAL_ROOT}'" \
        "'${MULLE_ENV_HOST_VAR_DIR}'" \
        "'${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}'" \
        "'${PATH}'" \
        "'${mode}'" \
        "'none/wild'" \
        "'${TRACE}'" \
        "'${ENVFILENAME}'" \
        "'${AUXENVFILENAME}'" \
        "'${NO_MOTD}'" \
        "${OPTION_SHELL_COMMAND}"  # already escaped!
}


env::print_env()
{
   log_entry "env::print_env" "$@"

   local sep
   local line
   local key
   local value

   sep=""
   while IFS= read line
   do
      key="${line%%=*}"
      if [ ! -z "${key}" ]
      then
         case "${key}" in
            *\!*|*\(*\)*)
               value="${line#*=}" # mingw craziness
            ;;

            *)
               r_shell_indirect_expand "${key}"
               value="${RVAL}"
            ;;
         esac

         if [ ! -z "${value}" ]
         then
            printf "${sep}%s=%s\n" "${key}" "${value}"
            sep=" "
         fi
      fi
   done < <( env )
}


env::run_subshell()
{
   log_entry "env::run_subshell" "$@"

   local arg="$1"

   # callerdirectory is where we are called from
   local callerdirectory

   callerdirectory="${MULLE_EXECUTABLE_PWD}"

   # directory is where we are supposed to execute
   local directory

   case "${OPTION_DIRECTORY}" in
      PWD)
         directory="${PWD}"
      ;;

      "")
         if [ -z "${arg}" ]
         then
            directory="${callerdirectory}"
         else
            directory="$arg"
         fi
      ;;

      *)
         directory="${OPTION_DIRECTORY}"
      ;;
   esac

   if [ ! -d "${directory}" ]
   then
      local url

      case "${arg}" in
         *:*)
            url="${arg}"
         ;;

         *)
            env::usage "Unknown command \"${directory}\"" # sic
         ;;
      esac

      if [ ! -z "${url}" ]
      then
         if [ -z "`command -v git`" ]
         then
            fail "git not installed, can't clone stuff for you"
         fi

         r_extensionless_basename "${url}"
         directory="${RVAL}"
         log_verbose "Cloning from URL \"${arg}\" into \"${directory}\"..."
         exekutor git clone "${url}" "${directory}" || return 1
      fi
   fi

   env::default_setup_environment "${directory}" "${OPTION_SEARCHMODE}"

#   local etcdir
#   etcdir="${MULLE_ENV_ETC_DIR}"

   local sharedir
   local vardir

   sharedir="${MULLE_ENV_SHARE_DIR}"
   vardir="${MULLE_ENV_HOST_VAR_DIR}"

   env::check_version "${sharedir}" "${MULLE_VIRTUAL_ROOT}"

   [ ! -d "${MULLE_ENV_SHARE_DIR}" ] && fail "No environment found in \
\"${directory}\". Use \`mulle-env init\` to initialize it."

   local _style
   local _flavor

   if ! env::__get_saved_style_flavor "${vardir}" "${sharedir}"
   then
      env::fail_get_saved_style_flavor "${vardir}" "${sharedir}"
   fi

   local oldstyle
   local oldflavor

   oldstyle="${_style}"
   oldflavor="${_flavor}"

   if [ "${OPTION_STYLE}" != "DEFAULT" ]
   then
      env::__get_style_flavor "${OPTION_STYLE}"
   fi

   local inherit_path
   local runpath
   local rundirectory

   runpath=""

   case "${_style}" in
      */*)
      ;;

      *) # no / like none
         _style="none/${_style}"
      ;;
   esac

   if ! env::load_flavor_plugin "${_flavor}"
   then
      if [ "${_style}" != "${oldstyle}" ]
      then
         fail "Plugin \"${_flavor}\" is not available. Current style is \"${oldstyle}\""
      fi
   fi

   case "${MULLE_UNAME}" in
      'mingw'|'msys')
         case "${_style}" in
            */wild)
            ;;

            *)
               _style="${_style%/*}/wild"
               log_info "On ${MULLE_UNAME} only style ${_style} is possible"
            ;;
      esac
   esac

   case "${_style}" in
      */wild)
         inherit_path="${PATH}"
      ;;

      */inherit)
         inherit_path="${PATH}"
      ;;

      */relax)
         env::r_censored_path "${PATH}"
         inherit_path="${RVAL}"
      ;;

      */tight|*/restrict)
         inherit_path=""
      ;;

      *)
         fail "unknown style \"${_style}\""
      ;;
   esac

#   if [ -z "`command -v sed`" ]
#   then
#      fail "sed not installed, can't run subshell"
#   fi

   local customenvironment

   customenvironment="${CUSTOM_ENVIRONMENT}"
   case "${_style}" in
      */restrict|*/tight|*/relax)

         [ -z "${MULLE_HOSTNAME}" ] && _internal_fail "MULLE_HOSTNAME \
undefined (old mulle-bashfunctions)"

         env::setup_if_needed "${directory}" \
                              "${vardir}" \
                              "${sharedir}" \
                              "${_style}" \
                              "${_flavor}" \
                              "${oldstyle}" \
                              "${oldflavor}"

         r_colon_concat "${runpath}" "${vardir}/bin"
         r_colon_concat "${RVAL}" "${MULLE_ENV_VAR_DIR}/bin"
         runpath="${RVAL}"

         r_concat "${customenvironment}" "MULLE_OLDPATH='${PATH}'"
         customenvironment="${RVAL}"
      ;;
   esac

   #
   # Have /usr and /usr/bin in the back
   # It obscures less problems and reflects the original PATH better.
   #
   r_colon_concat  "${runpath}" "${inherit_path}"
   runpath="${RVAL}"

   # mulle tools must be in front of /usr/bin, otherwise i can't develop this
   #
   # done by mulle plugin
   #
   #   r_colon_concat "${MULLE_VIRTUAL_ROOT}/.mulle/bin" "${runpath}"
   #  runpath="${RVAL}"

   env::r_apply_flavor_to_runpath "${MULLE_VIRTUAL_ROOT}" "${_flavor}" "${runpath}"
   runpath="${RVAL}"

   log_debug "future PATH=${runpath}"

   #
   # not sure about this really anymore
   #
   rundirectory="${MULLE_VIRTUAL_ROOT}"
   if [ "${OPTION_SEARCHMODE}" = 'SUPERIOR' ]
   then
      rundirectory="${callerdirectory}"
   fi
   env::apply_style_to_directory "${rundirectory}" "${sharedir}" "${_style}" "${_flavor}"

   #
   # remember old environment in "var" as export statements
   # for later use by "mudo -e" with env -i (if required)
   #
   log_fluff "Saving current environment into ${vardir}/old-environment"

   redirect_exekutor "${vardir}/old-environment" env

   local mode

   if [ ! -z "${OPTION_SHELL_COMMAND}" ]
   then
      # used by mulle-sde style set
      if [ "${OPTION_SHELL_COMMAND}" = ":" ]
      then
         return
      fi

      log_verbose "Run shell command \"${OPTION_SHELL_COMMAND}\" (${MULLE_VIRTUAL_ROOT})"
      mode="SCRIPT"
      [ -z "${MULLE_USER_PWD}" ] && _internal_fail "MULLE_USER_PWD must be set"
   else
      log_verbose "Starting ${_style#*/} shell (${MULLE_VIRTUAL_ROOT})"
      mode="INTERACTIVE"
      unset MULLE_USER_PWD
   fi


   if [ "${PWD}" != "${rundirectory}" ]
   then
      exekutor cd "${rundirectory}" || exit 1
   fi

#   local script
#
#   case "${MULLE_UNAME}" in
#      android)
#         script="${MULLE_ENV_LIBEXEC_DIR}/mulle-env-shell.sh"
#      ;;
#
#      *)
         script="${MULLE_ENV_LIBEXEC_DIR}/mulle-env-shell"
#      ;;
#   esac

   local rval

   env::invoke_shell "${_style#*/}" \
                      "${customenvironment}" \
                      "'${script}'" \
                      "'${MULLE_UNAME}'" \
                      "'${MULLE_HOSTNAME}'" \
                      "'${MULLE_USERNAME}'" \
                      "'${MULLE_VIRTUAL_ROOT}'" \
                      "'${MULLE_ENV_HOST_VAR_DIR}'" \
                      "'${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}'" \
                      "'${runpath}'" \
                      "'${mode}'" \
                      "'${_style}'" \
                      "'${TRACE:-}'" \
                      "'${ENVFILENAME}'" \
                      "'${AUXENVFILENAME}'" \
                      "'${NO_MOTD:-}'" \
                      "${OPTION_SHELL_COMMAND}"
   rval=$?

   log_debug "Subshell exited with $rval"
   return $rval
}

MULLE_ENVIRONMENT_KEYS="\
MULLE_UNAME
MULLE_HOSTNAME \
MULLE_USERNAME \
MULLE_VIRTUAL_ROOT \
MULLE_ENV_HOST_VAR_DIR \
MULLE_BASHFUNCTIONS_LIBEXEC_DIR \
TRACE \
ENVFILENAME \
AUXENVFILENAME \
NO_MOTD"


RELAX_ENVIRONMENT_KEYS="\
DBUS_SESSION_BUS_ADDRESS
DISPLAY \
EDITOR \
HOME \
LOGNAME \
LS_COLORS \
MULLE_ENV_PLUGIN_PATH \
MULLE_NO_COLOR \
MULLE_SDE_EXTENSION_PATH \
MULLE_USER_PWD \
MULLE_VIRTUAL_ROOT \
NO_COLOR \
PS1 \
SSH_CONNECTION \
SSH_TTY \
TERM \
TMPDIR \
USER \
USERNAME \
VISUAL \
"

#
# this is more lowlevel, it executes with a limited environment a shell command
# it doesn't use the mulle-env environment. It's rarely useful except to run
# like env -i with some environments intact.
#
# But it doesn't need a .mulle directory
#
env::invoke_shell()
{
   log_entry "env::invoke_shell" "$@"

   local envstyle="$1"
   local customenvironment="$2"

   shift 2

   local s
   local env_flag

   s=""
   env_flag="-i"

   #
   #
   #
   case "${envstyle}" in
      wild)
         unset MULLE_EXECUTABLE_NAME
         # unset MULLE_ENV_PLUGIN_PATH # don't do this because its needed for mulle-sde upgrade
         unset MULLE_USAGE_NAME
         env_flag=""   # do not suppress environment
      ;;

      tight)
         # USERNAME is used by mulle-env to discern environment files and styles
         [ ! -z "${LOGNAME}" ]    && r_concat "${s}" "LOGNAME='${LOGNAME}'" && s="${RVAL}"
      ;;

      relax|restrict|inherit)
         [ ${DISPLAY+x} ]         && r_concat "${s}" "DISPLAY='${DISPLAY}'" && s="${RVAL}"
         [ ${EDITOR+x} ]          && r_concat "${s}" "EDITOR='${EDITOR}'" && s="${RVAL}"
         [ ${HOME+x} ]            && r_concat "${s}" "HOME='${HOME}'" && s="${RVAL}"
         [ ${LOGNAME+x} ]         && r_concat "${s}" "LOGNAME='${LOGNAME}'" && s="${RVAL}"
         [ ${LS_COLORS+x} ]       && r_concat "${s}" "LS_COLORS='${LS_COLORS}'" && s="${RVAL}"
         [ ${NO_COLOR+x} ]        && r_concat "${s}" "NO_COLOR='${NO_COLOR}'" && s="${RVAL}"
         [ ${PS1+x} ]             && r_concat "${s}" "PS1='${PS1}'" && s="${RVAL}"
         [ ${SSH_CONNECTION+x} ] \
                                       && r_concat "${s}" "SSH_CONNECTION='${SSH_CONNECTION}'" && s="${RVAL}"
         [ ${SSH_TTY+x} ]         && r_concat "${s}" "SSH_TTY='${SSH_TTY}'" && s="${RVAL}"
         [ ${MULLE_ENV_PLUGIN_PATH+x} ]    && r_concat "${s}" "MULLE_ENV_PLUGIN_PATH='${MULLE_ENV_PLUGIN_PATH}'" && s="${RVAL}"
         [ ${MULLE_SDE_EXTENSION_PATH+x} ] && r_concat "${s}" "MULLE_SDE_EXTENSION_PATH='${MULLE_SDE_EXTENSION_PATH}'" && s="${RVAL}"
         [ ${MULLE_USER_PWD+x} ]  && r_concat "${s}" "MULLE_USER_PWD='${MULLE_USER_PWD}'" && s="${RVAL}"
         [ ${MULLE_NO_COLOR+x} ]  && r_concat "${s}" "MULLE_NO_COLOR='${MULLE_NO_COLOR}'" && s="${RVAL}"
         [ ${TERM+x} ]            && r_concat "${s}" "TERM='${TERM}'" && s="${RVAL}"
         [ ${TMPDIR+x} ]          && r_concat "${s}" "TMPDIR='${TMPDIR}'" && s="${RVAL}"
         [ ${USER+x} ]            && r_concat "${s}" "USER='${USER}'" && s="${RVAL}"
         # mingw is USERNAME
         [ ${USERNAME+x} ]        && r_concat "${s}" "USERNAME='${USERNAME}'" && s="${RVAL}"
         [ ${VISUAL+x} ]          && r_concat "${s}" "VISUAL='${VISUAL}'" && s="${RVAL}"
         [ ${DBUS_SESSION_BUS_ADDRESS+x} ] \
                                  && r_concat "${s}" "DBUS_SESSION_BUS_ADDRESS='${DBUS_SESSION_BUS_ADDRESS}'" && s="${RVAL}"
      ;;

      *)
         fail "unknown envstyle \"${envstyle}\""
      ;;
   esac

   # needed to get termux going
   case "${MULLE_UNAME}" in
      android)
         case "${envstyle}" in
            tight|relax|restrict|inherit)
            [ ${PREFIX+x} ]     && r_concat "${s}" "PREFIX='${PREFIX}'" && s="${RVAL}"
            [ ${LD_PRELOAD+x} ] && r_concat "${s}" "LD_PRELOAD='${LD_PRELOAD}'" && s="${RVAL}"
         ;;
      esac
   esac

   eval_exekutor env ${env_flag} \
                     "${s}" \
                     "${customenvironment}" \
                     "$@"
}


env::assert_valid_environment_key()
{
   log_entry "env::assert_valid_environment_key" "$@"

   local key="$1"

   local identifier

   r_identifier "${key}"
   identifier="${RVAL}"

   case "${OPTION_IDENTIFIERCASE}" in
      UPPERCASE_ONLY)
         r_uppercase "${identifier}"
         identifier="${RVAL}"
      ;;
   esac

   if [ "${key}" != "${identifier}" ]
   then
      fail "\"${key}\" is not a valid environment identifier"
   fi
}


env::define_custom_environment()
{
   log_entry "env::define_custom_environment" "$@"

   local keyvalue="$1"

   if [ -z "${keyvalue}" ]
   then
      fail "Missing key, directly after -D"
   fi

   local key
   local value

   key="${keyvalue%%=*}"

   if [ -z "${key}" ]
   then
      key="${keyvalue}"
   else
      value="${keyvalue#*=}"
   fi

   env::assert_valid_environment_key "${key}"

   r_concat "${CUSTOM_ENVIRONMENT}" "${key}='${value}'"
   CUSTOM_ENVIRONMENT="${RVAL}"
}


env::clean()
{
   log_entry "env::clean" "$@"

   env::default_setup_environment "${PWD}" "${OPTION_SEARCHMODE}"

   # shellcheck source=src/mulle-env-clean.sh
   . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-clean.sh" \
      || fail "failed to load \"${MULLE_ENV_LIBEXEC_DIR}/mulle-env-clean.sh\""

   env::clean::main "$@"
}


env::reset()
{
   env::clean "$@" && env::default_setup_environment "${PWD}" "${OPTION_SEARCHMODE}"
}



env::reinit()
{
   local directory
   local envdirectory

   directory="${MULLE_VIRTUAL_ROOT:-${PWD}}"
   case "${MULLE_UNAME}" in
      windows)
         envdirectory="${HOME}/.mulle/${directory##*/}.var/${MULLE_HOSTNAME}/env"
      ;;

      *)
         envdirectory="${directory}/.mulle/var/${MULLE_HOSTNAME}/env"
      ;;
   esac

   local fallback

   fallback="${directory}/.mulle/share/env"
   r_simplified_absolutepath "${envdirectory}"
   envdirectory="${RVAL}"
   r_simplified_absolutepath "${fallback}"
   fallback="${RVAL}"

   local _style
   local _flavor

   _style="${OPTION_STYLE}"
   if [ "${_style}" = "DEFAULT" ]
   then
      if ! env::__get_saved_style_flavor "${envdirectory}" "${fallback}"
      then
         env::fail_get_saved_style_flavor "${envdirectory}" "${fallback}"
      fi
   fi
   # shellcheck source=src/mulle-env-init.sh
   . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-init.sh" || exit 1

   MULLE_FLAG_MAGNUM_FORCE='YES'
   env::init::main --style "${_style}" --reinit
   return $?
}

#
# it assumed flags are parsed and the command like "envrionment" is
# also parsed
#
env::is_help_request_commandline()
{
   case "$1" in
      -h|--help|help)
         return 0
      ;;
   esac
   return 1
}


env::main()
{
   # todo rename these to FLAG
   local OPTION_DIRECTORY=""
   local OPTION_SHELL_COMMAND=""
   local OPTION_KEEP_TMP='NO'
   local MULLE_FLAG_MAGNUM_FORCE="NO"
   local OPTION_STYLE="DEFAULT"
   local OPTION_SEARCHMODE="DEFAULT"
   local OPTION_PROTECT="YES"
   local OPTION_SCOPE_SUBDIRS=

   local MULLE_TRACE
   local MULLE_FLAG_EXEKUTOR_DRY_RUN='NO'
   local MULLE_FLAG_LOG_DEBUG='NO'
   local MULLE_FLAG_LOG_EXEKUTOR='NO'
   local MULLE_FLAG_LOG_SETTINGS='NO'
   local MULLE_FLAG_LOG_FLUFF='NO'
   local MULLE_FLAG_LOG_VERBOSE='NO'
   local MULLE_FLAG_LOG_TERSE='NO'
   local OPTION_COPY_MULLE_TOOL='NO'
   local CUSTOM_ENVIRONMENT=""
   local FLAG_OUTSIDE_ENV='NO'
   local RESTRICTED_PATH=""

   # mingw needs different values here

   case "${MULLE_UNAME}" in
      "")
         _internal_fail "MULLE_UNAME not set"
      ;;

      android)
         RESTRICTED_PATH="/data/data/com.termux/files/usr/bin:/bin"
      ;;

      *)
         RESTRICTED_PATH="/usr/bin:/bin"
      ;;
   esac

   local arg

   while [ $# -ne 0 ]
   do
      if options_technical_flags "$1"
      then
         shift
         continue
      fi

      case "$1" in
         -h*|--help|help)
            env::usage
         ;;

         -e|--environment-override)
            FLAG_OUTSIDE_ENV='YES'
         ;;

         --shell)
            if [ ${ZSH_VERSION+x} ]
            then
               echo "zsh"
            else
               echo "bash"
            fi
            exit 0
         ;;

         --echo-args)
            shift
            printf "%s\n" "$@"
            exit 0
         ;;

         -c)
            #
            # memo same as bash, only one argument which will be evaled
            #
            [ $# -eq 1 ] && env::usage "Missing argument to $1"
            shift

            OPTION_SHELL_COMMAND="$1"
            printf -v OPTION_SHELL_COMMAND "%q" "${OPTION_SHELL_COMMAND}"
         ;;

         -C)
            [ $# -eq 1 ] && env::usage "Missing argument to $1"
            shift

            OPTION_SHELL_COMMAND=

            #
            # the only way to preserve empty lines properly is read AFAIK
            # -C doesn't expand contents
            #
            while IFS= read -r arg
            do
               printf -v arg "%q" "${arg}"
               if [ -z "${OPTION_SHELL_COMMAND}" ]
               then
                  OPTION_SHELL_COMMAND="${arg}"
               else
                  OPTION_SHELL_COMMAND="${OPTION_SHELL_COMMAND} ${arg}"
               fi
            done <<< "$1"

            printf -v OPTION_SHELL_COMMAND "%q" "${OPTION_SHELL_COMMAND}"
         ;;

         -f|--force)
            MULLE_FLAG_MAGNUM_FORCE='YES'
         ;;

         --freeze)
            OPTION_COPY_MULLE_TOOL='YES'
            MULLE_FLAG_MAGNUM_FORCE='YES'
         ;;

         -d|--directory)
            [ $# -eq 1 ] && env::usage "Missing argument to $1"
            shift

            OPTION_DIRECTORY="$1"
         ;;

         --defines)
            [ $# -eq 1 ] && env::usage "Missing argument to $1"
            shift

            while read -r arg
            do
               arg="${arg#-D}"
               arg="${arg## }"
               if [ ! -z "${arg}" ]
               then
                  if ! env::define_custom_environment "${arg}"
                  then
                     exit 1
                  fi
               fi
            done <<< "$1"
         ;;

         -D*)
            arg="${1#-D}"
            arg="${arg## }"
            if ! env::define_custom_environment "${arg}"
            then
               exit 1
            fi
         ;;

         -ef|--environment-file)
            [ $# -eq 1 ] && env::usage "Missing argument to $1"
            shift

            ENVFILENAME="$1"
         ;;

         -aef|--aux-environment-file)
            [ $# -eq 1 ] && env::usage "Missing argument to $1"
            shift

            AUXENVFILENAME="$1"
         ;;

         --keep-tmp)
            OPTION_KEEP_TMP='YES'
         ;;

         --no-motd)
            NO_MOTD='YES'
         ;;

         # the default anyway
         --protect)
            OPTION_PROTECT='YES'
         ;;

         # here the idea is that a tool that issues multiple mulle-env calls
         # uses this to indicate that env should a) not validate accesses
         # and b) not protect/unprotect files
         #
         --no-protect)
            OPTION_PROTECT='NO'
         ;;

         --scope-subdir)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            r_add_line "${OPTION_SCOPE_SUBDIRS}" "$1"
            OPTION_SCOPE_SUBDIRS="${RVAL}"
         ;;

         --style)
            [ $# -eq 1 ] && env::usage "Missing argument to $1"
            shift

            OPTION_STYLE="$1"
         ;;

         --search-here)
            OPTION_SEARCHMODE='HERE'
         ;;

         --search-as-is)
            OPTION_SEARCHMODE='AS_IS'
         ;;

         -N|--search-nearest)
            OPTION_SEARCHMODE='NEAREST'
         ;;

         --search-default)
            OPTION_SEARCHMODE='DEFAULT'
         ;;

         --search-none)
            OPTION_SEARCHMODE='NONE'
         ;;

         -P|--search-parent)
            OPTION_SEARCHMODE='PARENT'
         ;;

         -S|--search-superior)
            OPTION_SEARCHMODE='SUPERIOR'
         ;;

         --uppercase-only)
            OPTION_IDENTIFIERCASE='UPPERCASE_ONLY'
         ;;

         --)
            break
         ;;

         # argument gitflags
         -*)
            env::usage "Unknown flag \"$1\""
         ;;

         *)
            break
         ;;
      esac

      shift
   done

   options_setup_trace "${MULLE_TRACE:-}" && set -x
   export MULLE_TRACE

   local url

   arg="${1:-}"
   [ $# -ne 0 ] && shift

   #
   # if directory is there go there, except if we are doing an init
   #
   if [ ! -z "${OPTION_DIRECTORY}" -a "$arg" != "init" ] && [ -d "${OPTION_DIRECTORY}" ]
   then
      exekutor cd "${OPTION_DIRECTORY}" || exit 1
      OPTION_DIRECTORY="PWD"
   fi

   case "${arg}" in
      '--')
         arg="$1"
         [ $# -ne 0 ] && shift
      ;;

      'clean')
         env::clean "$@"
         return $?
      ;;

      'mulle-bin-dir')
         env::default_setup_environment "${PWD}" "${OPTION_SEARCHMODE}"
         printf "%s\n" "${MULLE_ENV_VAR_DIR}/bin"
         return 0
      ;;

      'mulle-libexec-dir')
         env::default_setup_environment "${PWD}" "${OPTION_SEARCHMODE}"
         printf "%s\n" "${MULLE_ENV_VAR_DIR}/libexec"
         return 0
      ;;

      'env'|'environment')
         # shellcheck source=src/mulle-env-environment.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-environment.sh" || exit 1

         if ! env::is_help_request_commandline "$@"
         then
            env::default_setup_environment "${PWD}" "${OPTION_SEARCHMODE}"
         fi

         env::environment::main --protect-flag "${OPTION_PROTECT}" "$@"
         return $?
      ;;

      # shortcuts for environment
      'get'|'set'|'list')
         # shellcheck source=src/mulle-env-environment.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-environment.sh" || exit 1

         if ! env::is_help_request_commandline "$@"
         then
            env::default_setup_environment "${PWD}" "${OPTION_SEARCHMODE}"
         fi
         env::environment::main --protect-flag "${OPTION_PROTECT}" "${arg}" "$@"
         return $?
      ;;

      'hostname')
         printf "%s\n" "${MULLE_HOSTNAME}"
         return 0
      ;;

      'init')
         # shellcheck source=src/mulle-env-init.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-init.sh" || exit 1

         env::init::main --style "${OPTION_STYLE}" "$@" || return $?
         ( cd "${RVAL}" && env::clean ) 
         return $?
      ;;

      'install-dir')
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-plugin.sh" || exit 1

         r_plugin_installdir

         log_info "Plugin installation directory"
         printf "%s\n" "${RVAL}"
         return
      ;;

      'invoke')
         env::define_custom_environment "PATH=${PATH}"
         env::invoke_shell "restrict" \
                           "${CUSTOM_ENVIRONMENT}" \
                           "$@"
         return
      ;;

      'local')
         # just return a status (not sure what this command is used for..)
         # but NONE seems important. Use project-dir for most cases
         if env::r_find_best_environment "${PWD}" "NONE"
         then
            log_info "YES"
            return 0
         fi

         log_warning "NO"
         return 1
      ;;

      # move this to mulle-bashfunctions or ?
      'mulle-tool-env')
         [ $# -eq 0 ] && env::usage "Missing argument to \"${arg}\""
         [ $# -ne 1 ] && env::usage "Superflous arguments to \"${arg}\""

         # should possibly create output like ssh-agent
         # so tools get MULLE_MATCH_ETC_DIR
         # so tools get MULLE_MATCH_VAR_DIR
         # so tools get MULLE_MATCH_SHARE_DIR
         # and they can source it
         if ! env::default_setup_environment "${PWD}" "${OPTION_SEARCHMODE}" 'YES' 'NO'
         then
            # silently error
            return 1
         fi

         local upper

         r_uppercase "$1"
         upper="${RVAL}"

         r_filepath_concat "${MULLE_ENV_HOST_VAR_DIR%/*}" "${1}"
         if [ ! -z "${RVAL}" ]
         then
            printf "MULLE_${upper}_VAR_DIR='%s'\n" "${RVAL}"
         fi

         r_filepath_concat "${MULLE_ENV_ETC_DIR%/*}" "${1}"
         if [ ! -z "${RVAL}" ]
         then
            printf "MULLE_${upper}_ETC_DIR='%s'\n" "${RVAL}"
         fi
         r_filepath_concat "${MULLE_ENV_SHARE_DIR%/*}" "${1}"
         if [ ! -z "${RVAL}" ]
         then
            printf "MULLE_${upper}_SHARE_DIR='%s'\n" "${RVAL}"
         fi
         return $?
      ;;

      'project-dir')
         env::r_find_best_environment "${PWD}" "${OPTION_SEARCHMODE}"
         if [ -z "${RVAL}" ]
         then
            return 1
         fi
         printf "%s\n" "${RVAL}"
         return 0
      ;;

      'reinit')
         env::reinit "$@"
         return $?
      ;;

      'reset')
         env::reset "$@"
         return $?
      ;;

      'scope'|'scopes')
         # shellcheck source=src/mulle-env-scope.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-scope.sh" || exit 1

         if ! env::is_help_request_commandline "$@"
         then
            env::default_setup_environment "${PWD}" "${OPTION_SEARCHMODE}"
         fi
         env::scope::main "$@"
         return $?
      ;;

      'searchpath')
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-plugin.sh" || exit 1

         log_info "Plugin searchpath"

         env::plugin::r_searchpath
         printf "%s\n" "${RVAL}"
         return
      ;;


      'style'|'styles')
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-style.sh" || exit 1

         env::style::main "$@"
         return $?
      ;;

      'subenv')
         if [ -z "${MULLE_VIRTUAL_ROOT}" ]
         then
            fail "\"subenv\" must be called from inside a subshell"
         fi

         [ $# -eq 0 ] && env::usage "Missing argument to \"${arg}\""
         [ $# -ne 1 ] && env::usage "Superflous arguments to \"${arg}\""

         env::run_subenv "$1"
         return $?
      ;;

      'tool')
         # do not set MULLE_VIRTUAL_ROOT if not already set
         if ! env::is_help_request_commandline "$@"
         then
            env::default_setup_environment "${PWD}" "${OPTION_SEARCHMODE}" 'NO'
         fi

         # shellcheck source=src/mulle-env-tool.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-tool.sh" || exit 1

         env::tool::main "$@"
         return $?
      ;;


      'tweak')
         env::default_setup_environment "${PWD}" "${OPTION_SEARCHMODE}"
         mkdir_if_missing "${MULLE_ENV_ETC_DIR}/tweak"
         redirect_exekutor "${MULLE_ENV_ETC_DIR}/tweak/$1" echo "intentionally blank"
         return $?
      ;;

      'uname'|'osname')
         printf "%s\n" "${MULLE_UNAME}"
         return 0
      ;;

      'unveil')
         # do not set MULLE_VIRTUAL_ROOT if not already set
         if ! env::is_help_request_commandline "$@"
         then
            env::default_setup_environment "${PWD}" "${OPTION_SEARCHMODE}" 'NO'
         fi

         # shellcheck source=src/mulle-env-unveil.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-unveil.sh" || exit 1

         env::unveil::main "$@"
         return $?
      ;;

      'username')
         printf "%s\n" "${MULLE_USERAME}"
         return 0
      ;;

      'untweak')
         # shellcheck source=src/mulle-env-environment.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-environment.sh" || exit 1

         env::default_setup_environment "${PWD}" "${OPTION_SEARCHMODE}"
         remove_file_if_present "${MULLE_ENV_ETC_DIR}/tweak/$1"
         rmdir_if_empty "${MULLE_ENV_ETC_DIR}/tweak"
         return $?
      ;;

      'upgrade')
         MULLE_FLAG_MAGNUM_FORCE='YES'

         # shellcheck source=src/mulle-env-init.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-init.sh" || exit 1

         env::init::main --upgrade --style "${OPTION_STYLE}" "$@" || exit 1
         env::reset
         return $?
      ;;

      'libexec-dir')
         printf "%s\n" "${MULLE_ENV_LIBEXEC_DIR}"
         return 0
      ;;


      'version')
         printf "%s\n" "${MULLE_EXECUTABLE_VERSION}"
         return 0
      ;;


      "")
      ;;

      *)
         OPTION_DIRECTORY="${cmd}"
         [ $# -eq 0 ] || env::usage "Superflous argument \"${arg}\""
      ;;
   esac

   #
   # lets do this for now
   #
   if [ ${MULLE_VIRTUAL_ROOT+x} ]
   then
      if [ ! -z "${MULLE_VIRTUAL_ROOT}" ]
      then
         fail "You are already in the virtual \
environment \"${MULLE_VIRTUAL_ROOT}\". Environments don't stack. (${PWD#"${MULLE_USER_PWD}/"})"
      fi
   fi

   # inherits all options ....

   env::run_subshell "${arg}"
}


call_with_flags "env::main" "${MULLE_ENV_FLAGS:-}" "$@"
