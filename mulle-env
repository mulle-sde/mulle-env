#! /usr/bin/env bash
#
#   Copyright (c) 2015 Nat! - Mulle kybernetiK
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are met:
#
#   Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
#   Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
#   Neither the name of Mulle kybernetiK nor the names of its contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
[ "${TRACE}" = 'YES' -o "${MULLE_ENV_TRACE}" = 'YES' ] && set -x && : "$0" "$@"

MULLE_ENV_VERSION="1.0.0"

#
# The default for first time mulle-env
#
MULLE_ENV_DEFAULT_STYLE="developer/relax"
ENVFILENAME="environment.sh"


emit_options()
{
   cat <<EOF
   -ef <file>    : use a different environment file (${ENVFILENAME})
   -c <cmd>      : shell command to execute instead of interactive subshell
   -C <cmd>      : like -c, but command and each argument are separated by LF
   -d <dir>      : specify directory
   -p <path>     : specify an additional plugin search path
   -s <tool/env> : enter subshell with a certain style (${MULLE_ENV_DEFAULT_STYLE})
   -DKEY=VALUE   : define one-time environment variable
EOF

   if [ ! -z "${MULLE_TRACE}" ]
   then
      options_technical_flags_usage "         : "
   fi
}


usage()
{
   [ $# -ne 0 ] && log_error "$1"

    cat <<EOF >&2
Usage:
   ${MULLE_USAGE_NAME} [options] [commands] [path-or-url]

   Create a virtual environment with a custom set of environment variables
   and tools for use in a subshell. If the directory at "path-or-url" does not
   exist and the path looks like an URL, then ${MULLE_USAGE_NAME} will attempt
   to \`git clone\` that URL.

   Use the -c or -C options to run commands in the virtual environment
   without entering an interactive subshell.

EOF

   if [ ! -z "${MULLE_TRACE}" ]
   then
      cat <<EOF >&2
   Use style "none/wild" for no PATH and environment restrictions. Aliases
   and shell settings will still be suppressed.

EOF
   fi

   cat <<EOF >&2
Commands:
   environment   : manage subshell environment variables
   envstyles     : list available environment styles
   init          : set up the subshell for the first time
   subenv        : enter a sub environment
   tool          : manage subshell tools
   toolstyles    : list available tool styles (including plugins)
   upgrade       : upgrade a subshell to a newer mulle-env version
   uname         : return the ${MULLE_USAGE_NAME} specfic uname
   version       : return the ${MULLE_USAGE_NAME} version
   --            : enter the subshell

Options:
EOF
   emit_options | LC_ALL=C sort >&2

   if [ ! -z "${MULLE_TRACE}" ]
   then
      cat <<EOF >&2

Tool-style: (built-in only, see \`mulle-sde toolstyles\` for all available)
   none          : a fairly empty virtual environment
   minimal       : a minimal set of tools (like cd, ls)
   developer     : a common set of tools (like cd, ls, awk, man) (default)

Env-style:
   tight         : all environment variables are user defined
   relax         : none + inherit some environment (e.g. SSH_TTY) (default)
   restrict      : relax + all /bin and /usr/bin tools
   inherit       : restrict + all PATH tools
   wild          : no restrictions

EOF
   else
      echo "      (use -v help to see more usage text)"
   fi

  exit 1
}


r_censored_path()
{
   log_entry "r_censored_path" "$@"

   local i
   local j

   RVAL=""

   set -f ; IFS=":"
   for i in $*
   do
      for j in ${RESTRICTED_PATH}
      do
         set +f ; IFS="${DEFAULT_IFS}"

         if [ "$i" = "$j" ]
         then
            r_colon_concat "${RVAL}" "${i}"
            result="${RVAL}"
         fi

         set -f ; IFS=":"
      done
   done

   set +f ; IFS="${DEFAULT_IFS}"
}


#
# since all mulle- tools are uniform, this is easy.
# If it's a library, we need to strip off -env from
# the toolname for the libraryname. Also libexec is versionized
# so add the version
#
env_link_mulle_tool()
{
   log_entry "env_link_mulle_tool" "$@"

   local toolname="$1"
   local dstbindir="$2"
   local dstlibexecdir="$3"
   local copystyle="${4:-tool}"

   #
   # these dependencies should be there, but just check
   #
   local exefile

   exefile="`command -v "${toolname}" `"
   if [ -z "${exefile}" ]
   then
      fail "${toolname} not in PATH"
   fi

   # doing it like this renames "src" to $toolname

   local srclibexecdir
   local parentdir
   local srclibname

   srclibdir="`exekutor "${exefile}" libexec-dir `" || exit 1
   r_fast_dirname "${srclibdir}"
   srclibexecdir="${RVAL}"
   r_fast_basename "${srclibdir}"
   srclibname="${RVAL}"

   local dstbindir
   local dstexefile
   local dstlibname

   dstlibname="${toolname}"
   dstexefile="${dstbindir}/${toolname}"
   mkdir_if_missing "${dstbindir}"

   if [ "${copystyle}" = "library" ]
   then
      local version

      version="`"${exefile}" version `" || exit 1
      dstlibname="`sed 's/-env$//' <<< "${toolname}" `"
      dstlibdir="${dstlibexecdir}/${dstlibname}/${version}"
   else
      dstlibdir="${dstlibexecdir}/${dstlibname}"
   fi

   # remove previous symlinks or files
   remove_file_if_present "${dstexefile}"
   remove_file_if_present "${dstlibdir}" || rmdir_safer "${dstlibdir}"

   #
   # Developer option, since I don't want to edit copies. Doesn't work
   # on mingw, but shucks.
   #
   if [ "${srclibname}" = "src" -a "${MULLE_ENV_DEVELOPER}" != 'NO' ]
   then
      mkdir_if_missing "${dstbindir}"
      mkdir_parent_if_missing "${dstlibdir}" > /dev/null

      log_fluff "Creating symlink \"${dstexefile}\""

      exekutor ln -s -f "${exefile}" "${dstexefile}"
      exekutor ln -s -f "${srclibexecdir}/src" "${dstlibdir}"
   else
      mkdir_if_missing "${dstlibdir}"

      ( cd "${srclibdir}" ; tar cf - . ) | \
      ( cd "${dstlibdir}" ; tar xf -  )

      mkdir_if_missing "${dstbindir}"

      log_fluff "Copying \"${dstexefile}\""

      exekutor cp "${exefile}" "${dstexefile}" &&
      exekutor chmod 755 "${dstexefile}"
   fi
}


env_link_other_tool()
{
   log_entry "env_link_other_tool" "$@"

   local toolname="$1"
   local bindir="$2"
   local isrequired="$3"

   local filename

   filename="`command -v "${toolname}" `"
   if [ -z "${filename}" ]
   then
      if [ "${isrequired}" = 'YES' ]
      then
         fail "Required tool \"${toolname}\" not found"
      fi

      log_fluff "\"${toolname}\" not found, but it's optional"
      return 1
   fi

   log_fluff "Creating symlink \"${bindir}/${toolname}\""

   exekutor ln -sf "${filename}" "${bindir}"
}


env_link_other_tools()
{
   log_entry "env_link_other_tools" "$@"

   local toolnames="$1"
   local bindir="$2"
   local isrequired="$3"

   local toolname

   local bindir

   mkdir_if_missing "${bindir}"

   set -f ; IFS="
"
   for toolname in ${toolnames}
   do
      set +f ; IFS="${DEFAULT_IFS}"

      if [ -z "${toolname}" ]
      then
         continue
      fi

      env_link_other_tool "${toolname}" "${bindir}" "${isrequired}"
   done

   set +f ; IFS="${DEFAULT_IFS}"

   rmdir_if_empty "${bindir}"
}


find_tool_file()
{
   local name="$1"; shift

   local directory
   local filename

   set -o noglob;  IFS="
"
   for directory in "$@"
   do
      set +o noglob; IFS="${DEFAULT_IFS}"

      filename="${directory}/${name}.${MULLE_UNAME}"
      [ -f "${filename}" ] && echo "${filename}" && return

      filename="${directory}/${name}"
      [ -f "${filename}" ] && echo "${filename}" && return
   done
   set + noglob; IFS="${DEFAULT_IFS}"
}


env_other_tool_files()
{
   log_entry "env_other_tool_files" "$@"

   local directory="$1"

   [ -z "${directory}" ] && internal_fail "directory must not be empty"

   if [ ! -z "${HOME}" ]
   then
      find_tool_file "tool" "${HOME}/.config"
      find_tool_file "optionaltool" "${HOME}/.config"
   fi

   find_tool_file "tool" "${MULLE_ENV_DIR}/etc" "${MULLE_ENV_DIR}/share"
   find_tool_file "optionaltool" "${MULLE_ENV_DIR}/etc" "${MULLE_ENV_DIR}/share"
}


env_setup_other_tools()
{
   log_entry "env_setup_other_tools" "$@"

   local toolfiles="$1"
   local bindir="$2"

   local tools
   local toolfile

   set -f ; IFS="
"
   for toolfile in ${toolfiles}
   do
      set +f ; IFS="${DEFAULT_IFS}"

      if tools="`cat "${toolfile}" `"
      then
         case "${toolfile}" in
            optional-*|*/optional-*)
               env_link_other_tools "${tools}" "${bindir}" 'NO'
            ;;

            *)
               env_link_other_tools "${tools}" "${bindir}" 'YES'
            ;;
         esac
      fi
   done
   set +f ; IFS="${DEFAULT_IFS}"

   return 0
}


env_setup_if_needed()
{
   log_entry "env_setup_if_needed" "$@"

   local cachedir="$1"
   local bindir="$2"
   local libexecdir="$3"
   local style="$4"
   local flavor="$5"
   local oldstyle="$6"
   local oldflavor="$7"

   local needs_flavor_update
   local needs_bin_update
   local needs_bin_update2

   needs_flavor_update=
   needs_bin_update=

   #
   # unprotect. Since these dirs are not in .git it should be OK
   # if the directory is read only
   #
   if [ -d "${bindir}" ]
   then
      exekutor chmod -R ug+w "${bindir}"
   fi
   if [ -d "${libexecdir}" ]
   then
      exekutor chmod -R ug+w "${libexecdir}"
   fi

   local callback

   #
   # need to do this to convert from developer back to minimal or none
   #
   if [ "${style}" != "${oldstyle}" ]
   then
      rmdir_safer "${cachedir}"
      rmdir_safer "${bindir}"
      rmdir_safer "${libexecdir}"
   fi

   if [ "${flavor}" != "${oldflavor}" ]
   then
      log_info "You affected a tool style change from \
\"${oldflavor}\" to \"${flavor}\". You may want to
check your tool list.
   ${C_RESET_BOLD} mulle-env tool list"
   fi

   callback="env_${flavor}_tools_need_update"
   if [ "`type -t "${callback}"`" = "function" ]
   then
      if ${callback} "${directory}"
      then
         log_fluff "Flavor \"${flavor}\" needs update"
         needs_flavor_update='YES'
      else
         log_fluff "Flavor \"${flavor}\" is up-to-date"
      fi
   fi

   local toolfile
   local oldhost
   local uptodatefile
   local myhost

   uptodatefile="${cachedir}/tools-updated"

   oldhost="`cat "${uptodatefile}" 2> /dev/null`"

   if [ ! -z "${oldhost}" -a "${oldhost}" != "${myhost}" ]
   then
      log_fluff "Regenerating tools as the host has changed"

      if [ -f "${uptodatefile}" ]
      then
         remove_file_if_present "${uptodatefile}"
      fi
   fi

   IFS="
"
   for toolfile in `env_other_tool_files "${directory}"`
   do
      IFS="${DEFAULT_IFS}"

      if [ "${MULLE_FLAG_MAGNUM_FORCE}" = 'YES' -a -f "${toolfile}" ] || \
         [ "${toolfile}" -nt "${uptodatefile}" ]
      then
         log_fluff "Tools \"${toolfile}\" needs update"
         needs_bin_update="`add_line "${needs_bin_update}" "${toolfile}" `"
      fi
   done
   IFS="${DEFAULT_IFS}"

   local rval

   if [ ! -z "${needs_bin_update}" -o ! -z "${needs_flavor_update}" ]
   then
      (
         local callback

         callback="env_setup_${flavor}_tools"
         if [ "`type -t "${callback}"`" = "function" ]
         then
            ${callback} "${bindir}" "${libexecdir}" || exit 1
         fi

         if [ ! -z "${needs_bin_update}" ]
         then
            env_setup_other_tools "${needs_bin_update}" "${bindir}"

            log_fluff "Writing \"${uptodatefile}\""

            mkdir_if_missing "${cachedir}" &&
            redirect_exekutor "${uptodatefile}" date
         fi
      )
      rval=$?
   else
      log_verbose "Nothing needs to be updated"
      rval=0
   fi

   #
   # protect from accidents
   #
   if [ -d "${libexecdir}" ]
   then
      exekutor chmod -R ugo-w "${libexecdir}"
   fi

   if [ -d "${bindir}" ]
   then
      exekutor chmod -R ugo-w "${bindir}"
   fi

   [ "$rval" -eq 0 ] || exit 1
}


#
# also check version
#
__get_saved_style_flavor()
{
   log_entry "__get_saved_style_flavor" "$@"

   local directory="$1"
   local fallback="$2"

   # make foo:bar foo/bar for backwards compatibility
   style=""
   if [ -f "${directory}/style" ]
   then
      style="`sed -e '/^#/d' -e 's|:|/|g' "${directory}/style" `"
   else
      if [ -f "${fallback}/style" ]
      then
         style="`sed -e '/^#/d' -e 's|:|/|g' "${fallback}/style" `"
      fi
   fi

   if [ -z "${style}" ]
   then
      r_simplified_absolutepath "${directory}"
      directory="${RVAL}"

      if [ "${directory%%/.mulle-env/etc}" != "${MULLE_USER_PWD}" ]
      then
         fail "No properly setup environment found in candidate project \
directory \"${directory}\" or \"${fallback}\" - style is missing."
      else
         fail "No properly setup environment found in \
\"${directory}\" or \"${fallback}\" - style is missing."
      fi
   fi
   flavor="${style%%/*}"
}


__check_version()
{
   log_entry "__check_version" "$@"

   local fallback="$1"

   if [ "${MULLE_FLAG_MAGNUM_FORCE}" != 'YES' ]
   then
      local version

      version="`grep -v '^#' "${fallback}/version" 2> /dev/null`"
      case "${version}" in
         "")
            fail "This is an incomplete environment with no version information."
         ;;

         0\.*)
            # incompatible change of -c execution, otherwise try to support
            # and make this a warning
            fail "This environment with version ${version} is too old for
mulle-env ${MULLE_ENV_VERSION}.
${C_INFO}You can upgrade it to ${MULLE_ENV_VERSION} with \`mulle-env upgrade\`"
         ;;

         1\.*)
         ;;

         *)
            fail "This environment requires a newer mulle-env version >= ${version}"
         ;;
      esac
   fi
}


__get_user_style_flavor()
{
   log_entry "__get_user_style_flavor" "$@"

   local option="$1"

   style="${option}"
   if [ "${style}" = "DEFAULT" ]
   then
      style="${MULLE_ENV_DEFAULT_STYLE}"
   fi
   flavor="${style%%/*}"
}


__load_flavor_plugin()
{
   log_entry "__load_flavor_plugin" "$@"

   local flavor="$1"

   # shellcheck source=src/mulle-env-plugins.sh
   . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-plugins.sh" || exit 1

   local searchpath
   local RVAL

   r_plugin_searchpath
   searchpath="${RVAL}"

   if ! _env_load_plugin "${flavor}" "${searchpath}"
   then
      if [ "${MULLE_FLAG_MAGNUM_FORCE}" != 'YES' ]
      then
         fail "No plugin \"${flavor}\" found in \"${searchpath}\".
${C_INFO}Fixes:
   * install the missing mulle-env plugin or modify MULLE_ENV_PLUGIN_PATH
   * use ${MULLE_USAGE_NAME} -f to skip this check.
   * change to an available style with ${MULLE_USAGE_NAME} --style"
      fi
      return 1
   else
   	log_verbose "Using plugin ${C_MAGENTA}${C_BOLD}${flavor}"
   fi
}


r_find_best_environment()
{
   log_entry "r_find_best_environment" "$@"

   local start="$1"
   local search="$2"
   local useclimb="$3"

   local directory
   local best

   best="${start}"
   r_absolutepath "${start}"
   directory="${RVAL}"  # paranoia

   while :
   do
      r_fast_dirname "${directory}"
      directory="${RVAL}"

      # look for .mulle-env/*/environment.sh going up to root, if we
      # find one, we latch onto it
      if [ "${directory}" = "/" ]
      then
         RVAL="${best}"
         return
      fi

      # use globbing
      if [ -f "${directory}/".mulle-env/share/environment.sh ]
      then
         if [ "${search}" != 'YES' ]
         then
            log_info "Using the superior mulle-env environment at \
${C_RESET_BOLD}${directory}${C_INFO}.
Suppress this behaviour with the flag \"-N\" or permanently suppress on a
per environment basis with:
   ${C_RESET_BOLD}mulle-env tweak stay"
         fi

         best="${directory}"

         if [ "${useclimb}" = 'YES' ]
         then
            if [ ! -f "${directory}/".mulle-env/etc/climb ]
            then
               RVAL="${best}"
               return
            fi
         fi
      fi
   done
}


apply_style_to_directory()
{
   log_entry "apply_style_to_directory" "$@"

   local directory="$1"
   local sharedir="$2"
   local style="$3"
   local flavor="$4"

   local callback

   callback="env_${flavor}_enter_subshell"
   if [ "`type -t "${callback}"`" = "function" ]
   then
      ${callback} "${directory}" "${style}"
   fi

   # memorize new style
   # since this always changes on user reques its in etc
   mkdir_if_missing "${MULLE_ENV_DIR}/etc"
   redirect_exekutor "${MULLE_ENV_DIR}/etc/style" echo "${style}"
}


r_apply_flavor_to_runpath()
{
   log_entry "r_apply_flavor_to_runpath" "$@"

   local directory="$1"
   local flavor="$2"
   local runpath="$3"

   local callback

   RVAL="${runpath}"
   callback="env_r_${flavor}_add_runpath"
   if [ "`type -t "${callback}"`" = "function" ]
   then
      ${callback} "${directory}" "${RVAL}"
   fi
}


_setup_environment()
{
   log_entry "_setup_environment" "$@"

   local directory="$1"

   local physicaldir

   physicaldir="`physicalpath "${directory}" `"
   [ ! -d "${physicaldir}" ] && internal_fail "physicalpath failed"
   [ "${physicaldir}" = "/" ] && fail "Running in / which is not supported"

   MULLE_VIRTUAL_ROOT="${physicaldir}"

   log_verbose "MULLE_VIRTUAL_ROOT set to \"${MULLE_VIRTUAL_ROOT}\""

   MULLE_ENV_DIR="${physicaldir}/.mulle-env"

   log_fluff "MULLE_ENV_DIR set to \"${MULLE_ENV_DIR}\""
}


_default_setup_environment()
{
   log_entry "_default_setup_environment" "$@"

   local directory="${1:-${PWD}}"
   local search="$2"
   local searchbydefault="$3"

   local useclimb
   local dosearch

   useclimb="YES"
   if [ "${search}" = 'YES' ]
   then
      useclimb="NO"
   fi

   dosearch="${search}"
   if [ "${search}" = 'DEFAULT' -a "${searchbydefault}" = "YES" ]
   then
      dosearch="YES"
   fi

   if [ "${dosearch}" = 'YES' ]
   then
      local RVAL

      r_find_best_environment "${PWD}" "${search}" "${useclimb}"
      directory="${RVAL}"
   fi

   [ ! -d "${directory}" ] && fail "${directory} does not exist (init it first)"

   _setup_environment "${directory}"
}


#
# run shell or command in an inferior mulle-env environment
# This is "wild" style. We don't manipulate the PATH and we
# don't clean the environment. But we augment it with the
# variables set in the inferior ENVFILENAME
#
_run_subenv()
{
   log_entry "_run_subenv" "$@"

   local directory="$1"

   directory="`simplified_absolutepath "${directory:-${PWD}}"`"

   if [ ! -d "${directory}/.mulle-env" ]
   then
      [ -d "${directory}" ] || fail "\"${directory}\" not found"
      fail "No mulle-env found in \"${directory}\""
   fi

   # might need to be smarter here
   case "${directory}" in
      "../"*|*"/.."|*"/../"*|"./"*|*"/."|*"/./"*|"~/"*|*"/~"|*"/~/"*)
         fail "${directory} must not have relative components"
      ;;
   esac


   MULLE_VIRTUAL_ROOT="${directory}"

   local mode

   if [ ! -z "${OPTION_SHELL_COMMAND}" ]
   then
      log_verbose "Run subenv shell command \
\"${OPTION_SHELL_COMMAND}\" ($MULLE_VIRTUAL_ROOT})"
      mode="SUBENV:SCRIPT"
   else
      log_info "Starting subenv shell in \
${C_RESET_BOLD}${MULLE_VIRTUAL_ROOT#${PWD}/}${C_INFO}."
      mode="SUBENV:INTERACTIVE"
   fi

   if [ "${PWD}" != "${directory}" ]
   then
      exekutor cd "${directory}" || exit 1
   fi

   eval_exekutor env \
      "${CUSTOM_ENVIRONMENT}" \
      "'${MULLE_ENV_LIBEXEC_DIR}/mulle-env-shell'" \
        "'${MULLE_UNAME}'" \
        "'${MULLE_HOSTNAME}'" \
        "'${MULLE_VIRTUAL_ROOT}'" \
        "'${PATH}'" \
        "'${mode}'" \
        "'none/wild'" \
        "'${ENVFILENAME}'" \
        "'${TRACE}'" \
        "'${NO_MOTD}'" \
        "${OPTION_SHELL_COMMAND}"  # already escaped!
}


_run_subshell()
{
   log_entry "_run_subshell" "$@"

   # callerdirectory is where we are called from
   local callerdirectory

   # directory is where we are supposed to execute
   local directory


   callerdirectory="${MULLE_EXECUTABLE_PWD}"

   if [ ! -z "${OPTION_DIRECTORY}" ]
   then
      directory="${OPTION_DIRECTORY}"
   else
      if [ -z "${arg}" ]
      then
         directory="${callerdirectory}"
      else
         directory="$arg"
      fi
   fi

   local RVAL

   if [ ! -d "${directory}" ]
   then
      local url

      case "${arg}" in
         *:*)
            url="${arg}"
         ;;
      esac

      if [ ! -z "${url}" ]
      then
         if [ -z "`command -v git`" ]
         then
            fail "git not installed, can't clone stuff for you"
         fi

         r_extensionless_basename "${url}"
         directory="${RVAL}"
         log_verbose "Cloning from URL \"${arg}\" into \"${directory}\"..."
         exekutor git clone "${url}" "${directory}" || return 1
      fi
   fi

   _default_setup_environment "${directory}" "${OPTION_SEARCH}" "NO"

   [ ! -d "${MULLE_ENV_DIR}" ] && fail "No environment found in \
\"${directory}\". Use \`mulle-env init\` to initialize it."

   local etcdir
   local sharedir
   local vardir

   etcdir="${MULLE_ENV_DIR}/etc"
   sharedir="${MULLE_ENV_DIR}/share"
   vardir="${MULLE_ENV_DIR}/var"

   local style
   local flavor

   __check_version "${sharedir}"
   __get_saved_style_flavor "${etcdir}" "${sharedir}"

   local oldstyle
   local oldflavor

   oldstyle="${style}"
   oldflavor="${flavor}"

   if [ "${OPTION_STYLE}" != "DEFAULT" ]
   then
      __get_user_style_flavor "${OPTION_STYLE}"
   fi

   local inherit_path
   local runpath
   local rundirectory

   case "${style}" in
      */*)
      ;;

      *) # no / like none
         style="none/${style}"
      ;;
   esac

   if ! __load_flavor_plugin "${flavor}"
   then
      if [ "${style}" != "${oldstyle}" ]
      then
         fail "Plugin \"${flavor}\" is not available. Current style is \"${oldstyle}\""
      fi
   fi

   local s

   s=""

   local env_flag

   env_flag="-i"

   case "${style}" in
      */wild)
         inherit_path="${PATH}"
         env_flag=""   # do not suppress environment
      ;;

      */inherit)
         inherit_path="${PATH}"
      ;;

      */restrict)
         r_censored_path "${PATH}"
         inherit_path="${RVAL}"
      ;;

      */tight|*/relax)
         inherit_path=""
      ;;

      *)
         fail "unknown style \"${style}\""
      ;;
   esac

   case "${style}" in
      */restrict|*/tight|*/relax)
         local bindir
         local libexecdir
         local cachedir

         [ -z "${MULLE_HOSTNAME}" ] && internal_fail "MULLE_HOSTNAME \
undefined (old mulle-bashfunctions)"

         cachedir="${vardir}/${MULLE_HOSTNAME}/cache"
         bindir="${vardir}/${MULLE_HOSTNAME}/bin"
         libexecdir="${vardir}/${MULLE_HOSTNAME}/libexec"

         env_setup_if_needed "${cachedir}" \
                             "${bindir}" \
                             "${libexecdir}" \
                             "${style}" \
                             "${flavor}" \
                             "${oldstyle}" \
                             "${oldflavor}"

         r_colon_concat "${runpath}" "${bindir}"
         runpath="${RVAL}"
         r_concat "${s}" "MULLE_OLDPATH='${PATH}'"
         s="${RVAL}"
      ;;
   esac

   local RVAL

   r_colon_concat "${runpath}" "${inherit_path}"
   runpath="${RVAL}"
   r_apply_flavor_to_runpath "${MULLE_VIRTUAL_ROOT}" "${flavor}" "${runpath}"
   runpath="${RVAL}"

   log_debug "future PATH=${runpath}"

   rundirectory="${MULLE_VIRTUAL_ROOT}"
   if [ "${OPTION_SEARCH}" = 'YES' ]
   then
      rundirectory="${callerdirectory}"
   fi
   apply_style_to_directory "${rundirectory}" "${sharedir}" "${style}" "${flavor}"

   #
   #
   #
   local mode

   if [ ! -z "${OPTION_SHELL_COMMAND}" ]
   then
      log_verbose "Run shell command \"${OPTION_SHELL_COMMAND}\" ($MULLE_VIRTUAL_ROOT})"
      mode="SCRIPT"
   else
      log_verbose "Starting shell ${env_flag} ($MULLE_VIRTUAL_ROOT})"
      mode="INTERACTIVE"
   fi

   case "${style}" in
      */wild)
         unset MULLE_EXECUTABLE_NAME
         # unset MULLE_ENV_PLUGIN_PATH # don't do this because its needed for mulle-sde upgrade
         unset MULLE_USAGE_NAME
      ;;

      */relax|*/restrict|*/inherit)
         [ ! -z "${DISPLAY}" ]   && r_concat "${s}" "DISPLAY='${DISPLAY}'" && s="${RVAL}"
         [ ! -z "${EDITOR}" ]    && r_concat "${s}" "EDITOR='${EDITOR}'" && s="${RVAL}"
         [ ! -z "${HOME}" ]      && r_concat "${s}" "HOME='${HOME}'" && s="${RVAL}"
         [ ! -z "${LOGNAME}" ]   && r_concat "${s}" "LOGNAME='${LOGNAME}'" && s="${RVAL}"
         [ ! -z "${LS_COLORS}" ] && r_concat "${s}" "LS_COLORS='${LS_COLORS}'" && s="${RVAL}"
         [ ! -z "${PS1}" ]       && r_concat "${s}" "PS1='${PS1}'" && s="${RVAL}"
         [ ! -z "${SSH_CONNECTION}" ] \
                                 && r_concat "${s}" "SSH_CONNECTION='${SSH_CONNECTION}'" && s="${RVAL}"
         [ ! -z "${SSH_TTY}" ]   && r_concat "${s}" "SSH_TTY='${SSH_TTY}'" && s="${RVAL}"
         [ ! -z "${TERM}" ]      && r_concat "${s}" "TERM='${TERM}'" && s="${RVAL}"
         [ ! -z "${TMPDIR}" ]    && r_concat "${s}" "TMPDIR='${TMPDIR}'" && s="${RVAL}"
         [ ! -z "${USER}" ]      && r_concat "${s}" "USER='${USER}'" && s="${RVAL}"
         [ ! -z "${VISUAL}" ]    && r_concat "${s}" "VISUAL='${VISUAL}'" && s="${RVAL}"
         [ ! -z "${DBUS_SESSION_BUS_ADDRESS}" ] \
                                 && r_concat "${s}" "DBUS_SESSION_BUS_ADDRESS='${DBUS_SESSION_BUS_ADDRESS}'" && s="${RVAL}"
      ;;
   esac

   #
   # home is needed for git
   # otherwise provide a minimal environment, for better reproducability
   #
   local rval

   if [ "${PWD}" != "${rundirectory}" ]
   then
      exekutor cd "${rundirectory}" || exit 1
   fi

   eval_exekutor env ${env_flag} \
          "${s}" \
          "${CUSTOM_ENVIRONMENT}" \
          "'${MULLE_ENV_LIBEXEC_DIR}/mulle-env-shell'" \
            "'${MULLE_UNAME}'" \
            "'${MULLE_HOSTNAME}'" \
            "'${MULLE_VIRTUAL_ROOT}'" \
            "'${runpath}'" \
            "'${mode}'" \
            "'${style}'" \
            "'${ENVFILENAME}'" \
            "'${TRACE}'" \
            "'${NO_MOTD}'" \
            "${OPTION_SHELL_COMMAND}" # already escaped!

   rval=$?

   log_debug "Subshell exited with $rval"
   return $rval
}


assert_valid_environment_key()
{
   log_entry "assert_valid_environment_key" "$@"

   local key="$1"

   local identifier

   case "${OPTION_IDENTIFIERCASE}" in
      UPPERCASE_ONLY)
         identifier="`printf "%s" "${key}" | tr -c 'a-zA-Z0-9' '_' | tr 'a-z' 'A-Z'`"
      ;;

      *)
         identifier="`printf "%s" "${key}" | tr -c 'a-zA-Z0-9' '_'`"
      ;;
   esac

   if [ "${key}" != "${identifier}" ]
   then
      fail "\"${key}\" is not a valid environment identifier"
   fi

   case "${identifier}" in
      [0-9]*)
         fail "\"${key}\" is not a valid environment identifier"
      ;;
   esac
}


define_custom_environment()
{
   log_entry "define_custom_environment" "$@"

   local keyvalue="$1"

   if [ -z "${keyvalue}" ]
   then
      fail "Missing key, directly after -D"
   fi

   local key
   local value

   key="${keyvalue%%=*}"

   if [ -z "${key}" ]
   then
      key="${keyvalue}"
   else
      value="${keyvalue#*=}"
   fi

   assert_valid_environment_key "${key}"

   local RVAL

   r_concat "${CUSTOM_ENVIRONMENT}" "${key}='${value}'"
   CUSTOM_ENVIRONMENT="${RVAL}"
}


main()
{
   # todo rename these to FLAG
   local OPTION_DIRECTORY
   local OPTION_SHELL_COMMAND
   local OPTION_KEEP_TMP='NO'
   local MULLE_FLAG_MAGNUM_FORCE=
   local OPTION_STYLE="DEFAULT"
   local OPTION_SEARCH="DEFAULT"

   local MULLE_TRACE
   local MULLE_FLAG_EXEKUTOR_DRY_RUN
   local MULLE_FLAG_LOG_DEBUG
   local MULLE_FLAG_LOG_EXEKUTOR
   local MULLE_FLAG_LOG_TERSE
   local CUSTOM_ENVIRONMENT

   local RESTRICTED_PATH

   # mingw needs different values here

   case "${MULLE_UNAME}" in
      "")
         internal_fail "MULLE_UNAME not set"
      ;;

      *)
         RESTRICTED_PATH="/usr/bin:/bin"
      ;;
   esac

   while [ $# -ne 0 ]
   do
      if options_technical_flags "$1"
      then
         shift
         continue
      fi

      case "$1" in
         -h*|--help|help)
            usage
         ;;

         -c)
            [ $# -eq 1 ] && usage "Missing argument to $1"
            shift

            # escape properly for later eval
            printf -v OPTION_SHELL_COMMAND "%q" "$1"
         ;;

         -C)
            [ $# -eq 1 ] && usage "Missing argument to $1"
            shift

            OPTION_SHELL_COMMAND=

            local arg

            set -o noglob; IFS="
"
            for arg in $1
            do
               if [ ! -z "${arg}" ]
               then
                  if [ -z "${OPTION_SHELL_COMMAND}" ]
                  then
                     OPTION_SHELL_COMMAND="'${arg}'"
                  else
                     OPTION_SHELL_COMMAND="${OPTION_SHELL_COMMAND} '${arg}'"
                  fi
               fi
            done
            IFS="${DEFAULT_IFS}"; set +o noglob

            printf -v OPTION_SHELL_COMMAND "%q" "${OPTION_SHELL_COMMAND}"
         ;;

         -f|--force)
            MULLE_FLAG_MAGNUM_FORCE='YES'
         ;;

         -d|--directory)
            [ $# -eq 1 ] && usage "Missing argument to $1"
            shift

            OPTION_DIRECTORY="$1"
         ;;

         -D*)
            local keyvalue

            local argument

            argument="`LC_ALL=C sed -e s'/^-D[ ]*//' <<< "$1" `"
            if ! define_custom_environment "${argument}"
            then
               exit 1
            fi
         ;;

         -ef|--environment-file)
            [ $# -eq 1 ] && usage "Missing argument to $1"
            shift

            ENVFILENAME="$1"
         ;;

         --keep-tmp)
            OPTION_KEEP_TMP='YES'
         ;;

         --no-motd)
            NO_MOTD='YES'
         ;;

         -s|--style)
            [ $# -eq 1 ] && usage "Missing argument to $1"
            shift

            OPTION_STYLE="$1"
         ;;

         -N|--no-search)
            OPTION_SEARCH='NO'
         ;;

         -S|--search)
            OPTION_SEARCH='YES'
         ;;

         --uppercase-only)
            OPTION_IDENTIFIERCASE='UPPERCASE_ONLY'
         ;;

         --)
            break
         ;;

         # argument gitflags
         -*)
            usage "Unknown flag \"$1\""
         ;;

         *)
            break
         ;;
      esac

      shift
   done

   options_setup_trace "${MULLE_TRACE}"
   export MULLE_TRACE

   local arg
   local url

   arg="$1"
   [ $# -ne 0 ] && shift

   case "${arg}" in
      --)
         arg="$1"
         [ $# -ne 0 ] && shift
      ;;

      init)
         # shellcheck source=src/mulle-env-init.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-init.sh" || exit 1

         env_init_main "$@"
         return $?
      ;;

      environment)
         # shellcheck source=src/mulle-env-environment.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-environment.sh" || exit 1

         _default_setup_environment "${PWD}" "${OPTION_SEARCH}" "NO"
         env_environment_main "$@"
         return $?
      ;;

      envstyles)
         echo "inherit
relax
restrict
tight
wild"
         return 0
      ;;

      hostname)
         echo "${MULLE_HOSTNAME}"
         return 0
      ;;

      reinit)

         local style
         local flavor

         __get_saved_style_flavor "${MULLE_VIRTUAL_ROOT:-.}/.mulle-env/etc" \
                                  "${MULLE_VIRTUAL_ROOT:-.}/.mulle-env/share"

         # shellcheck source=src/mulle-env-init.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-init.sh" || exit 1

         MULLE_FLAG_MAGNUM_FORCE='YES'
         env_init_main --style "${style}"
         return $?
      ;;

      style)
         local style
         local flavor
         local directory="$1"

         directory="${directory:-${MULLE_VIRTUAL_ROOT}}"
         directory="${directory:-.}"

         __get_saved_style_flavor "${directory}/.mulle-env/etc" \
                                  "${directory}/.mulle-env/share"
         echo "${style}"
         return 0
      ;;

      subenv)
         if [ -z "${MULLE_VIRTUAL_ROOT}" ]
         then
            fail "\"subenv\" must be called from inside a subshell"
         fi

         [ $# -eq 0 ] && usage "Missing argument to \"${arg}\""
         [ $# -ne 1 ] && usage "Superflous arguments to \"${arg}\""

         _run_subenv "$1"
         return $?
      ;;

      tool)
         # shellcheck source=src/mulle-env-tool.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-tool.sh" || exit 1

         _default_setup_environment "${PWD}" "${OPTION_SEARCH}" "NO"
         env_tool_main "$@"
         return $?
      ;;

      tweak)
         # shellcheck source=src/mulle-env-environment.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-environment.sh" || exit 1

         _default_setup_environment "${PWD}" "${OPTION_SEARCH}" "NO"
         mkdir_if_missing "${PWD}/.mulle-env/etc/tweak"
         redirect_exekutor "${PWD}/.mulle-env/etc/tweak/$1" echo "intentionally blank"
         return $?
      ;;

      untweak)
         # shellcheck source=src/mulle-env-environment.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-environment.sh" || exit 1

         _default_setup_environment "${PWD}" "${OPTION_SEARCH}" "NO"
         remove_file_if_present "${PWD}/.mulle-env/etc/tweak/$1"
         rmdir_if_empty "${PWD}/.mulle-env/etc/tweak"
         return $?
      ;;


      toolstyles)
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-plugins.sh" || exit 1

         env_all_plugin_names
         return $?
      ;;

      uname)
         echo "${MULLE_UNAME}"
         return 0
      ;;

      upgrade)
         MULLE_FLAG_MAGNUM_FORCE='YES'

         local style
         local flavor

         __get_saved_style_flavor "${MULLE_VIRTUAL_ROOT:-.}/.mulle-env/etc" \
                                  "${MULLE_VIRTUAL_ROOT:-.}/.mulle-env/share"

         # shellcheck source=src/mulle-env-init.sh
         . "${MULLE_ENV_LIBEXEC_DIR}/mulle-env-init.sh" || exit 1

         env_init_main --upgrade --style "${style}"
         return $?
      ;;

      *)
         if [ ! -z "${MULLE_VIRTUAL_ROOT}" ]
         then
            fail "Called from inside a subshell"
         fi
      ;;
   esac

   #
   # lets do this for now
   #
   if [ ! -z "${MULLE_VIRTUAL_ROOT}" ]
   then
      fail "You are already in the virtual \
environment \"${MULLE_VIRTUAL_ROOT}\". Environments don't stack."
   fi

   # inherits all options ....
   _run_subshell
}


########
###
### INIT
###
_init()
{
   if [ "$1" = "version" ]
   then
      echo "${MULLE_ENV_VERSION}"
      exit 0
   fi

   MULLE_BASHFUNCTIONS_LIBEXEC_DIR="`mulle-bashfunctions-env libexec-dir 2> /dev/null`"
   [ -z "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}" ] && \
      echo "mulle-bashfunctions-env not installed" >&2 && \
      exit 1

   . "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}/mulle-bashfunctions.sh" "minimal" || exit 1
   . "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}/mulle-path.sh" || exit 1
   . "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}/mulle-file.sh" || exit 1

   local _libexec_dir

   _get_libexec_dir "$0" "mulle-env" "mulle-env-shell"

   if [ -z "${_libexec_dir}" ]
   then
      fail "Fatal Error: Could not find libexec for ${MULLE_EXECUTABLE} ($PWD)"
   fi
   MULLE_ENV_LIBEXEC_DIR="${_libexec_dir}"

   #
   # minimal setup exit
   #
   if [ "$1" = "libexec-dir" ]
   then
      echo "${MULLE_ENV_LIBEXEC_DIR}"
      exit 0
   fi

   set -o pipefail
}


_init "$@"
main "$@"

