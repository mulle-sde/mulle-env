#! /usr/bin/env bash
#
#   Copyright (c) 2015 Nat! - Mulle kybernetiK
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are met:
#
#   Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
#   Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
#   Neither the name of Mulle kybernetiK nor the names of its contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
[ "${TRACE}" = "YES" ] && set -x && : "$0" "$@"

MULLE_ENV_VERSION="0.9.0"

#
# use mulle:restrict as the default suitable for first time mulle-sde
# users
#
MULLE_ENV_DEFAULT_STYLE="${MULLE_ENV_DEFAULT_STYLE:-mulle:restricted}"


usage()
{
    cat <<EOF >&2
Usage:
   ${MULLE_EXECUTABLE_NAME} [options] [commands] [path|url]

   Create a virtual environment for project in directory.
   If the directory at path does not exist and the path looks like an url,
   ${MULLE_EXECUTABLE} will attempt to git clone the project from that url.

   Styles are a toolstyle and a pathstyle, separated by ':'

Commands:
   init                 : set up the environment for the first time
   uname                : return the ${MULLE_EXECUTABLE_NAME} specfic uname
   version              : return the ${MULLE_EXECUTABLE_NAME} version
   --                   : enter the environment. Can be left out if path, url are
                          not named like the other commands.
Options:
   --style <tool:path>  : initialize environment with a certain flavor
   -c <cmd>             : shell command to execute instead of interactive shell
   -d <dir>             : specify different directory, than the one taken from the url
EOF
   options_technical_flags_usage "               : "

   cat <<EOF >&2

Tool-style:
   none                 : no additions
   mulle                : additionally support mulle-build (default)

Path-style:
   none                 : all tools must be specified in .mulle-env/etc/tools
   inherit              : inherit PATH, don't use tools links
   restrict             : /bin and /usr/bin are inherited. All other tools must
                          be specified.
EOF


  exit 1
}


censored_path()
{
   log_entry "censored_path" "$@"

   local result

   local i
   local j

   IFS=":"
   for i in $*
   do
      IFS=":"
      for j in ${RESTRICTED_PATH}
      do
         IFS="${DEFAULT_IFS}"

         if [ "$i" = "$j" ]
         then
            result="`colon_concat "${result}" "${i}"`"
         fi
      done
   done

   IFS="${DEFAULT_IFS}"

   if [ ! -z "${result}" ]
   then
      echo "${result}"
   fi
}


env_link_other_tool()
{
   log_entry "env_link_other_tool" "$@"

   local toolname="$1"
   local bindir="$2"
   local isrequired="$3"

   local filename

   filename="`command -v "${toolname}" `"
   if [ -z "${filename}" ]
   then
      if [ "${isrequired}" = "YES" ]
      then
         fail "Required tool \"${toolname}\" not found"
      fi

      log_fluff "\"${toolname}\" not found, but it's optional"
      return 1
   fi

   log_fluff "Creating symlink \"${bindir}/${toolname}\""

   exekutor ln -sf "${filename}" "${bindir}"
}


env_link_other_tools()
{
   log_entry "env_link_other_tools" "$@"

   local toolnames="$1"
   local directory="$2"
   local isrequired="$3"

   local toolname

   local bindir

   bindir="${directory}/bin"

   mkdir_if_missing "${bindir}"

   IFS="
"
   for toolname in ${toolnames}
   do
      IFS="${DEFAULT_IFS}"

      if [ -z "${toolname}" ]
      then
         continue
      fi

      env_link_other_tool "${toolname}" "${bindir}" "${isrequired}"
   done

   IFS="${DEFAULT_IFS}"

   rmdir_if_empty "${bindir}"
}


env_other_tool_files()
{
   log_entry "env_other_tool_files" "$@"

   local directory="$1"

   [ -z "${directory}" ] && internal_fail "directory must not be empty"

   if [ ! -z "${HOME}" ]
   then
      echo "${HOME}/.config/mulle-env/tools"
      echo "${HOME}/.config/mulle-env/optional-tools"
   fi

   echo "${directory}/etc/tools"
   echo "${directory}/etc/optional-tools"
}


env_setup_other_tools()
{
   log_entry "env_setup_other_tools" "$@"

   local toolfiles="$1"
   local directory="$2"

   local tools
   local toolfile

   IFS="
"
   for toolfile in ${toolfiles}
   do
      IFS="${DEFAULT_IFS}"

      if tools="`cat "${toolfile}" `"
      then
         case "${toolfile}" in
            optional-*|*/optional-*)
               env_link_other_tools "${tools}" "${directory}" "NO"
            ;;

            *)
               env_link_other_tools "${tools}" "${directory}" "YES"
            ;;
         esac
      fi
   done
   IFS="${DEFAULT_IFS}"

   return 0
}


env_setup_if_needed()
{
   log_entry "env_setup_if_needed" "$@"

   local directory="$1"
   local flavor="$2"

   local needs_flavor_update
   local needs_bin_update
   local needs_bin_update2

   needs_flavor_update=
   needs_bin_update=

   local etcdir
   local bindir
   local libexecdir
   local cachedir

   cachedir="${directory}/cache"
   etcdir="${directory}/etc"
   bindir="${directory}/bin"
   libexecdir="${directory}/libexecdir"

   local callback

   callback="env_${flavor}_tools_need_update"
   if [ "`type -t "${callback}"`" = "function" ]
   then
      if ${callback} "${directory}"
      then
         log_fluff "Flavor \"${flavor}\" needs update"
         needs_flavor_update="YES"
      else
         log_fluff "Flavor \"${flavor}\" is up-to-date"
      fi
   fi

   local toolfile
   local oldhost
   local uptodatefile
   local myhost

   uptodatefile="${cachedir}/tools-updated"

   oldhost="`cat "${uptodatefile}" 2> /dev/null`"
   myhost="`hostname -s`"

   if [ ! -z "${oldhost}" -a "${oldhost}" != "${myhost}" ]
   then
      log_fluff "Regenerating tools as the host has changed"

      exekutor chmod ug+w "${bindir}" 2> /dev/null
      remove_file_if_present "${uptodatefile}"
      exekutor chmod ug-w "${bindir}" 2> /dev/null
   fi

   IFS="
"
   for toolfile in `env_other_tool_files "${directory}"`
   do
      IFS="${DEFAULT_IFS}"

      if [ -f "${toolfile}.${UNAME}" ]
      then
         toolfile="${toolfile}.${UNAME}"
      fi

      if [ "${OPTION_MAGNUM_FORCE}" = "YES" -a -f "${toolfile}" ] || \
         [ "${toolfile}" -nt "${uptodatefile}" ]
      then
         log_fluff "Tools \"${toolfile}\" needs update"
         needs_bin_update="`add_line "${needs_bin_update}" "${toolfile}" `"
      fi
   done
   IFS="${DEFAULT_IFS}"

   if [ -z "${needs_bin_update}" -a -z "${needs_flavor_update}" ]
   then
      log_verbose "Nothing needs to be updated"
      return
   fi

   #
   # unprotect
   #
   exekutor chmod -R ug+w "${bindir}" 2> /dev/null
   exekutor chmod -R ug+w "${libexecdir}" 2> /dev/null

   local callback

   callback="env_setup_${flavor}_tools"
   if [ "`type -t "${callback}"`" = "function" ]
   then
      ${callback} "${directory}"
   fi

   if [ ! -z "${needs_bin_update}" ]
   then
      env_setup_other_tools "${needs_bin_update}" "${directory}"

      log_fluff "Writing \"${uptodatefile}\""

      mkdir_if_missing "${cachedir}"
      redirect_exekutor "${uptodatefile}" echo "${myhost}"
   fi

   #
   # protect from accidents
   #
   exekutor chmod -R ugo-w "${libexecdir}" 2> /dev/null
   exekutor chmod -R ugo-w "${bindir}" 2> /dev/null
}


__get_saved_style_flavor()
{
   log_entry "__get_saved_style_flavor" "$@"

   local etcdir="$1"

   style=""
   if [ -f "${etcdir}/style" ]
   then
      style="`sed -e '/^#/d' -e 's/--style //' < "${etcdir}/style" `"
   fi
   if [ -z "${style}" ]
   then
      fail "No mulle-env environment found.
You must ${C_RESET_BOLD}mulle-env init \"${etcdir}\"${C_ERROR} first before you can enter it."
   fi
   flavor="`cut -d: -f1 <<< "${style}"`"
}


__get_user_style_flavor()
{
   log_entry "__get_user_style_flavor" "$@"

   local option="$1"

   style="${option}"
   if [ "${style}" = "DEFAULT" ]
   then
      style="${MULLE_ENV_DEFAULT_STYLE}"
   fi
   flavor="`cut -d: -f1 <<< "${style}"`"
}


__load_flavor_plugin()
{
   log_entry "__load_flavor_plugin" "$@"

   local flavor="$1"

   . "${MULLE_ENV_LIBEXEC_DIR}/mulle-plugins.sh" || exit 1

   env_load_plugin "${flavor}"
}


env_init()
{
   log_entry "env_init" "$@"

   local OPTION_NINJA="DEFAULT"
   local OPTION_CMAKE="DEFAULT"
   local OPTION_SVN="DEFAULT"
   local OPTION_STYLE="DEFAULT"
   local OPTION_AUTOCONF="DEFAULT"
   local OPTION_OTHER_TOOLS=
   local OPTION_BLURB="DEFAULT"

   local directory

   directory="${PWD}"

   while [ $# -ne 0 ]
   do
      case "$1" in
         -h|--help)
            usage
         ;;

         -d|--directory)
            [ $# -eq 1 ] && fail "Missing argument to $1"
            shift

            directory="$1"
         ;;

         -f|--force)
            OPTION_MAGNUM_FORCE="YES"
         ;;

         --autoconf)
            OPTION_AUTOCONF="YES"
         ;;

         --no-autoconf)
            OPTION_AUTOCONF="NO"
         ;;

         --blurb)
            OPTION_BLURB="YES"
         ;;

         --no-blurb)
            OPTION_BLURB="NO"
         ;;

         --cmake)
            OPTION_CMAKE="YES"
         ;;

         --no-cmake)
            OPTION_CMAKE="NO"
         ;;

         --ninja)
            OPTION_NINJA="YES"
         ;;

         --no-ninja)
            OPTION_NINJA="NO"
         ;;

         --svn)
            OPTION_SVN="YES"
         ;;

         --no-svn)
            OPTION_SVN="NO"
         ;;

         --style)
            [ $# -eq 1 ] && fail "Missing argument to $1"
            shift

            OPTION_STYLE="$1"
         ;;

         -t|--tool)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            OPTION_OTHER_TOOLS="`add_line "${OPTION_OTHER_TOOLS}" "$1" `"
         ;;

         -*)
            fail "Unknown option \"$1\""
         ;;

         *)
            break
         ;;
      esac

      shift
   done

   local envfile
   local toolsfile
   local stylefile
   local versionfile
   local etcdir
   local sharedir
   local optional_toolsfile

   MULLE_ENV_DIR="${directory}/.mulle-env"

   etcdir="${MULLE_ENV_DIR}/etc"
   sharedir="${MULLE_ENV_DIR}/share"

   envfile="${sharedir}/environment.sh"
   # user editable stuff in etc
   auxfile="${etcdir}/environment-aux.sh"

   toolsfile="${etcdir}/tools"
   optional_toolsfile="${etcdir}/optional-tools"
   stylefile="${etcdir}/style"
   versionfile="${etcdir}/version"

   if [ "${OPTION_MAGNUM_FORCE}" != "YES" ] && [ -f "${envfile}" ]
   then
      log_warning "\"${envfile}\" already exists"
      return 2
   fi

   mkdir_if_missing "${etcdir}"
   mkdir_if_missing "${sharedir}"

   local style
   local flavor

   __get_user_style_flavor "${OPTION_STYLE}"
   __load_flavor_plugin "${flavor}"

   log_verbose "Creating \"${envfile}\""

   local text

   if ! text="`print_${flavor}_startup_sh "${style}" `"
   then
      return 1
   fi
   redirect_exekutor "${envfile}" echo "${text}"

   log_verbose "Creating \"${auxfile}\""
   if ! text="`print_${flavor}_aux_sh "${style}" `"
   then
      return 1
   fi
   redirect_exekutor "${auxfile}" echo "${text}"

   log_verbose "Creating \"${toolsfile}\""
   if ! text="`print_${flavor}_tools_sh "${style}" `"
   then
      return 1
   fi
   redirect_exekutor "${toolsfile}" echo "${text}"

   log_verbose "Creating \"${optional_toolsfile}\""
   if ! text="`print_${flavor}_optional_tools_sh "${style}" `"
   then
      return 1
   fi
   redirect_exekutor "${optional_toolsfile}" echo "${text}"

   log_verbose "Creating \"${stylefile}\""
   redirect_exekutor "${stylefile}" echo "--style ${style}"

   log_verbose "Creating \"${versionfile}\""
   redirect_exekutor "${versionfile}" echo "${MULLE_ENV_VERSION}"

   if [ "${OPTION_BLURB}" != "NO" ]
   then
      log_info "Enter the environment:
   ${C_RESET_BOLD}${MULLE_EXECUTABLE_NAME} \"${directory}\"${C_INFO}"
   fi
}


find_best_environment()
{
   log_entry "find_best_environment" "$@"

   local start="$1"

   local directory
   local best

   best="${start}"
   directory="`absolutepath "${start}"`"  # paranoia
   while :
   do
      directory="`dirname -- "${directory}"`"

      # look for .mulle-env/*/environment.sh going up to root, if we
      # find one, we latch onto it
      if [ "${directory}" = "/" ]
      then
         echo "${best}"
         return
      fi

      # use globbing
      if [ -f "${directory}/".mulle-env/*/environment.sh ]
      then
         log_info "Found and using a superior mulle-env environment at \
${C_RESET_BOLD}${directory}/.mulle-env${C_INFO}.
Suppress this behaviour with:
   ${C_RESET_BOLD}mulle-env --no-search"
         best="${directory}"
      fi
   done
}


apply_style_to_directory()
{
   log_entry "apply_style_to_directory" "$@"

   local directory="$1"
   local style="$2"
   local flavor="$3"

   local callback

   callback="env_${flavor}_enter_subshell"
   if [ "`type -t "${callback}"`" = "function" ]
   then
      ${callback} "${directory}"
   fi
}


apply_flavor_to_runpath()
{
   log_entry "apply_flavor_to_runpath" "$@"

   local directory="$1"
   local flavor="$2"
   local runpath="$3"

   local callback

   callback="env_${flavor}_add_runpath"
   if [ "`type -t "${callback}"`" = "function" ]
   then
      ${callback} "${directory}" "${runpath}"
   else
      echo "${runpath}"
   fi
}


main()
{
   log_entry "main" "$@"

   local OPTION_DIRECTORY
   local OPTION_BOOTSTRAP="NO"
   local OPTION_SHELL_COMMAND
   local OPTION_KEEP_TMP="NO"
   local OPTION_MAGNUM_FORCE=
   local OPTION_STYLE="DEFAULT"
   local OPTION_SEARCH="DEFAULT"

   local MULLE_FLAG_EXEKUTOR_DRY_RUN
   local MULLE_FLAG_LOG_DEBUG
   local MULLE_FLAG_LOG_EXEKUTOR
   local MULLE_FLAG_LOG_TERSE
   local MULLE_TRACE

   local RESTRICTED_PATH

   # mingw needs different values here
   MULLE_UNAME="${UNAME}"
   case "${MULLE_UNAME}" in
      *)
         RESTRICTED_PATH="/usr/bin:/bin"
      ;;
   esac

   while [ $# -ne 0 ]
   do
      if options_technical_flags "$1"
      then
         shift
         continue
      fi

      case "$1" in
         -h|--help)
            usage
         ;;

         -c)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            OPTION_SHELL_COMMAND="$1"
         ;;

         -f|--force)
            OPTION_MAGNUM_FORCE="YES"
         ;;

         -d|--directory)
            [ $# -eq 1 ] && fail "Missing argument to $1"
            shift

            OPTION_DIRECTORY="$1"
         ;;

         --search)
            OPTION_SEARCH="YES"
         ;;

         -ns|--no-search)
            OPTION_SEARCH="NO"
         ;;

         --bootstrap)
            OPTION_BOOTSTRAP="YES"
         ;;

         -nb|--no-bootstrap)
            OPTION_BOOTSTRAP="NO"
         ;;

         --keep-tmp)
            OPTION_KEEP_TMP="YES"
         ;;

         --)
            break
         ;;

         # argument gitflags
         -*)
            fail "Unknown flag \"$1\""
         ;;

         *)
            break
         ;;
      esac

      shift
   done

   options_setup_trace "${MULLE_TRACE}"
   export MULLE_TRACE

   #
   # lets do this for now
   #
   if [ ! -z "${MULLE_VIRTUAL_ROOT}" ]
   then
      fail "You are already in the virtual \
environment \"${MULLE_VIRTUAL_ROOT}\". Environments don't stack."
   fi

   local arg
   local url

   # callerdirectory is where we are called from
   local callerdirectory
   # directory is where we are supposed to execute
   local directory
   # MULLE_VIRTUAL_ROOT is where the .mulle-env/env/environment.sh is
   local MULLE_VIRTUAL_ROOT

   callerdirectory="`pwd -P`"

   arg="$1"
   [ $# -ne 0 ] && shift

   case "${arg}" in
      --)
         arg="$1"
         [ $# -ne 0 ] && shift
      ;;

      uname)
         echo "${MULLE_UNAME}"
         return 0
      ;;

      init)
         env_init "$@"
         return $?
      ;;
   esac

   if [ ! -z "${OPTION_DIRECTORY}" ]
   then
      directory="${OPTION_DIRECTORY}"
   else
      if [ -z "${arg}" ]
      then
         directory="${callerdirectory}"
         if [ "${OPTION_SEARCH}" = "DEFAULT" ]
         then
            OPTION_SEARCH="YES"
         fi

      else
         directory="$arg"
      fi
   fi

   if [ ! -d "${directory}" ]
   then
      local url

      case "${arg}" in
         *:*)
            url="${arg}"
         ;;
      esac

      if [ ! -z "${url}" ]
      then
         if [ -z "`command -v git`" ]
         then
            fail "git not installed, can't clone stuff for you"
         fi

         directory="`basename -- "${url}" .git`"
         log_verbose "Cloning from URL \"${arg}\" into \"${directory}\"..."
         git clone "${url}" "${directory}" || return 1
      fi
   fi

   if [ "${OPTION_SEARCH}" = "YES" ]
   then
      directory="`find_best_environment "${directory}"`"
   fi

   [ ! -d "${directory}" ] && fail "${directory} does not exist (init it first)"

   local physicaldir

   physicaldir="`physicalpath "${directory}" `"
   [ ! -d "${physicaldir}" ] && internal_fail "physicalpath failed"
   MULLE_VIRTUAL_ROOT="${physicaldir}"

   log_verbose "MULLE_VIRTUAL_ROOT set to \"${MULLE_VIRTUAL_ROOT}\""

   local MULLE_ENV_DIR

   MULLE_ENV_DIR="${physicaldir}/.mulle-env"

   local etcdir

   etcdir="${MULLE_ENV_DIR}/etc"

   local style
   local flavor

   __get_saved_style_flavor "${etcdir}"
   __load_flavor_plugin "${flavor}"

   local run_shell_args
   local inherit_path
   local runpath
   local rundirectory

   case "${style}" in
      *:*)
      ;;

      *) # no : like none
         style="${style:none}"
      ;;
   esac


   case "${style}" in
      *:inherit)
         inherit_path="${PATH}"
         # don't use .mulle-env/bin
      ;;

      *:restrict)
         env_setup_if_needed "${MULLE_ENV_DIR}" "${flavor}"
         inherit_path="`censored_path "${PATH}"`"
         runpath="`colon_concat "${runpath}" "${MULLE_ENV_DIR}/bin" `"
      ;;

      *:none)
         inherit_path=""
         env_setup_if_needed "${MULLE_ENV_DIR}" "${flavor}"
         runpath="`colon_concat "${runpath}" "${MULLE_ENV_DIR}/bin" `"
      ;;

      *)
         fail "unknown style \"${style}\""
      ;;
   esac


   runpath="`colon_concat "${runpath}" "${inherit_path}" `"
   runpath="`apply_flavor_to_runpath "${MULLE_VIRTUAL_ROOT}" "${flavor}" "${runpath}" `"

   log_debug "future PATH=${runpath}"

   rundirectory="${MULLE_VIRTUAL_ROOT}"
   if [ "${OPTION_SEARCH}" = "YES" ]
   then
      rundirectory="${callerdirectory}"
   fi
   apply_style_to_directory "${rundirectory}" "${style}" "${flavor}"

   #
   #
   #
   log_fluff "Run shell in \"${rundirectory}\"..."

   if [ ! -z "${OPTION_SHELL_COMMAND}" ]
   then
      run_shell_args="-c '${OPTION_SHELL_COMMAND}"
   fi

   local s

   s=""

   [ ! -z "${DISPLAY}" ]   && s="`concat "${s}" "DISPLAY='${DISPLAY}'"`"
   [ ! -z "${EDITOR}" ]    && s="`concat "${s}" "EDITOR='${EDITOR}'"`"
   [ ! -z "${HOME}" ]      && s="`concat "${s}" "HOME='${HOME}'"`"
   [ ! -z "${LOGNAME}" ]   && s="`concat "${s}" "LOGNAME='${LOGNAME}'"`"
   [ ! -z "${LS_COLORS}" ] && s="`concat "${s}" "LS_COLORS='${LS_COLORS}'"`"
   [ ! -z "${PS1}" ]       && s="`concat "${s}" "PS1='${PS1}'"`"
   [ ! -z "${SSH_CONNECTION}" ] \
                           && s="`concat "${s}" "SSH_CONNECTION='${SSH_CONNECTION}'"`"
   [ ! -z "${SSH_TTY}" ]   && s="`concat "${s}" "SSH_TTY='${SSH_TTY}'"`"
   [ ! -z "${TERM}" ]      && s="`concat "${s}" "TERM='${TERM}'"`"
   [ ! -z "${TMPDIR}" ]    && s="`concat "${s}" "TMPDIR='${TMPDIR}'"`"
   [ ! -z "${USER}" ]      && s="`concat "${s}" "USER='${USER}'"`"
   [ ! -z "${VISUAL}" ]    && s="`concat "${s}" "VISUAL='${VISUAL}'"`"
   [ ! -z "${DBUS_SESSION_BUS_ADDRESS}" ] \
                           && s="`concat "${s}" "DBUS_SESSION_BUS_ADDRESS='${DBUS_SESSION_BUS_ADDRESS}'"`"

   # remember old path
   s="`concat "${s}" "MULLE_OLDPATH='${PATH}'"`"

   #
   # home is needed for git
   # otherwise provide a minimal environment, for better reproducability
   #
   (
      cd "${rundirectory}" &&
      eval env -i \
             "${s}" \
             "'${MULLE_ENV_LIBEXEC_DIR}/mulle-env-shell'" \
               "'${MULLE_UNAME}'" \
               "'${MULLE_VIRTUAL_ROOT}'" \
               "'${runpath}'" \
               "INTERACTIVE" \
               "${TRACE}" \
               "${run_shell_args}"
   )
   return $?
}



########
###
### INIT
###
_init()
{
   if [ "$1" = "version" ]
   then
      echo "${MULLE_ENV_VERSION}"
      exit 0
   fi

   MULLE_BASHFUNCTIONS_LIBEXEC_DIR="`mulle-bashfunctions-env libexec-dir 2> /dev/null`"
   [ -z "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}" ] && \
      echo "mulle-bashfunctions-env not installed" >&2 && \
      exit 1

   . "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}/mulle-bashfunctions.sh" "minimal" || exit 1
   . "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}/mulle-path.sh" || exit 1
   . "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}/mulle-file.sh" || exit 1

   local _libexec_dir

   _get_libexec_dir "$0" "mulle-env" "mulle-env-shell"

   if [ -z "${_libexec_dir}" ]
   then
      fail "Fatal Error: Could not find libexec for ${MULLE_EXECUTABLE} ($PWD)"
   fi
   MULLE_ENV_LIBEXEC_DIR="${_libexec_dir}"

   #
   # minimal setup exit
   #
   if [ "$1" = "libexec-dir" ]
   then
      echo "${MULLE_ENV_LIBEXEC_DIR}"
      exit 0
   fi

   set -o pipefail
}


_init "$@"
main "$@"

